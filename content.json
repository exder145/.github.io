{"meta":{"title":"EXDER's Blog","subtitle":"欢迎来到EXDER的博客","description":"欢迎来到EXDER的博客","author":"EXDER","url":"https://exder145.github.io","root":"/"},"pages":[{"title":"","date":"2023-10-26T09:40:14.231Z","updated":"2023-10-26T09:40:14.231Z","comments":true,"path":"about/index.html","permalink":"https://exder145.github.io/about/index.html","excerpt":"","text":"In case I don’t see you, good morning,good afternoon and good night. ✨欢迎来到EXDER的博客。✨ ​ 🪄至此本博客的搭建就差不多完成了。虽然界面还没有让我很满意，但完善的工作就交给未来的自己吧（躺） ​ 🔮这个博客建立的初心（应该）主要是用于记录本人的学习历程，当然也会参杂各种学习心得（吐槽）和一些乱七八糟的不太冷知识。 ​ 💤以下是一些废话 ​ 简单介绍一下自己的话，本人的荣誉称号有：老师口中的极个别人，部门不必可少的划水的鱼，现充口中的死宅二刺螈，二次元眼中的臭鲜葱，没有酒精上瘾的跛脚调酒师，时常电子养胃的游戏低手，失败的时间管理大师，拥有美术生梦想的悲惨程序员，fe不算太低的entp，在自律挑战中打败了全球0%的人，有人生来就在罗马，有人出生变成马喽。 ​ 好像扯得有点远了。其实刚建立这个博客时还是有很多犹豫和自我质疑的，一部分原因是不知道三分钟热情的自己能坚持到哪一步,更主要的原因是本人目前基础非常差劲,摆烂的前半生造就了我的今天（悲） ​ （虽然如果再来一次我应该还是会选择摆烂这种话就先不要说了） ​ 所以看过很多大佬的博客后时常会质疑自己建立博客的目的。 如果只是做cs学习笔记的话，自己悄悄记下就好了，有什么必要发布出来呢？比我优秀的大有人在，这份博客又是想让谁看到呢？但是后来偶然翻到自己第一次敲出“HelloWorld”的截图，那份最单纯的欣喜和好奇，自信满满认为前路畅通无阻的幼稚的喜悦像回旋镖击中了已经摆烂一年的我。想要脱离落后-焦虑-摆烂的死循环，最好的办法不过是重头再来。所以本博客建立的主要目的还是记录和督促本人的日常学习，也欢迎大家一起捶打我。(笑 ​ 当然，如果未来有一天，本博客的内容能够给其他学习者带来一些启发，那将是我的莫大荣幸。 ⭐最后引用我很喜欢的JOJO7中的一句台词结束吧： ​ 初めてのキスはJOJOじやなぃ、konodioda！（不是这句 ​ 我现在还只是『负数』！我只是想让自己从『负数』变为『零』而已 ！ ​ —-2023.10.26"},{"title":"所有分类","date":"2023-10-24T13:18:09.367Z","updated":"2023-10-24T13:18:09.367Z","comments":true,"path":"categories/index.html","permalink":"https://exder145.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2025-01-22T08:46:38.348Z","updated":"2025-01-22T08:46:38.348Z","comments":true,"path":"css/custom.css","permalink":"https://exder145.github.io/css/custom.css","excerpt":"","text":"/* 加载动画容器 */ #loading-container { position: fixed; top: 0; left: 0; width: 100%; height: 100vh; background: var(--color-card); z-index: 999999; display: flex; justify-content: center; align-items: center; opacity: 1; visibility: visible; transition: all 0.5s; } #loading-container.hide { opacity: 0; visibility: hidden; } /* 加载动画 */ .loader { display: flex; position: relative; justify-content: center; align-items: center; gap: 1rem; height: 55px; width: 200px; } .container { position: relative; width: 24px; height: 24px; } /* 添加具体的动画元素样式 */ .love, .death, .robots { position: absolute; width: 20px; height: 20px; background: var(--color-text); border-radius: 50%; animation: bounce 1s infinite; } /* 为每个元素设置不同的动画延迟 */ .love { animation-delay: 0.1s; } .death { animation-delay: 0.2s; } .robots { animation-delay: 0.3s; } @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }"},{"title":"我的朋友们","date":"2023-10-24T13:18:44.838Z","updated":"2023-10-24T13:18:44.838Z","comments":true,"path":"friends/index.html","permalink":"https://exder145.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2023-10-24T13:18:22.737Z","updated":"2023-10-24T13:18:22.737Z","comments":true,"path":"tags/index.html","permalink":"https://exder145.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-12-27T05:30:19.175Z","updated":"2024-12-27T05:30:19.175Z","comments":true,"path":"js/custom.js","permalink":"https://exder145.github.io/js/custom.js","excerpt":"","text":"// 在页面加载前就执行 (function() { document.addEventListener('DOMContentLoaded', function() { const loadingContainer = document.getElementById('loading-container'); if (!loadingContainer) return; // 确保动画至少显示1秒 setTimeout(function() { loadingContainer.classList.add('hide'); setTimeout(function() { loadingContainer.style.display = 'none'; }, 500); }, 1000); }); // 如果页面加载太快也要显示动画 window.addEventListener('load', function() { const loadingContainer = document.getElementById('loading-container'); if (!loadingContainer || loadingContainer.classList.contains('hide')) return; loadingContainer.classList.add('hide'); setTimeout(function() { loadingContainer.style.display = 'none'; }, 500); }); })();"}],"posts":[{"title":"sql server无法连接的问题","slug":"sql server常见问题","date":"2024-12-24T16:00:00.000Z","updated":"2025-01-22T09:26:18.613Z","comments":true,"path":"2024/12/25/sql server常见问题/","link":"","permalink":"https://exder145.github.io/2024/12/25/sql%20server%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"记录一下 sql server 连接不上的问题","text":"记录一下 sql server 连接不上的问题 SQL Server 数据库连接问题连接测试用代码:12345678910111213141516171819202122232425import pymssql# 数据库连接信息 (修改为自己的)username = &#x27;sa&#x27;password = &#x27;hp6252&#x27;database = &#x27;news&#x27;server = &#x27;localhost&#x27;port = &#x27;1433&#x27;try: # 尝试连接数据库 connect = pymssql.connect(server=server, port=port, user=username, password=password, database=database) cursor = connect.cursor() print(&quot;连接成功！&quot;) # 执行简单查询 cursor.execute(&quot;SELECT 1&quot;) result = cursor.fetchone() print(&quot;查询结果:&quot;, result) # 关闭游标和连接 cursor.close() connect.close()except pymssql.Error as e: print(&quot;连接失败:&quot;, e) 能解决大部分问题的方案解决方案: 重启数据库服务 直接在任务管理器图示位置进行服务重启,或: 进入 CMD，输入 services.msc ，进入到服务页面,找到 SQL Server(SQLEXPRESS)右键重启。 可以顺手把启动方式该成自动。 后重新启动 ssms。进行验证 如果还是不能解决的方案若仍然无效，可通过以下步骤进行排查： 1. 确认 SQL Server 服务是否运行 打开“服务”管理工具 找到 SQL Server 服务（通常是以 SQL Server (MSSQLSERVER) 命名） 确认其状态为“正在运行”。 代码示例在命令提示符中可以使用以下命令来查看服务状态： 12sc query &quot;MSSQLSERVER&quot;1. 2. 检查网络连接如果 SQL Server 服务正常运行，下一步需要检查网络连接是否正常。可以通过 ping 命令测试连接： 12ping &lt;数据库服务器IP&gt;1. 代码示例假设数据库服务器的 IP 地址为 192.168.1.100，可以使用以下命令： 12ping 192.168.1.1001. 如果无法 ping 通，需检查网络设置或是否有防火墙阻止连接。 3. 验证 SQL Server 实例名和端口在连接数据库时，确保使用了正确的实例名和端口。如果使用的是默认实例，通常可以直接使用服务器的 IP 地址或主机名。如果使用的是命名实例，则需要在连接字符串中指定实例名。 例子默认实例连接字符串: 12Server=192.168.1.100;Database=SampleDB;User Id=myUsername;Password=myPassword;1. 命名实例连接字符串: 12Server=192.168.1.100\\SQLExpress;Database=SampleDB;User Id=myUsername;Password=myPassword;1. 4. 检查 SQL Server 配置管理器确保 SQL Server 正在接受远程连接。可以通过以下步骤在 SQL Server 配置管理器中进行检查： 打开 SQL Server 配置管理器 点击 “SQL Server 网络配置”，然后选择 “协议”。 确保 “TCP&#x2F;IP” 协议已启用。 5. 防火墙设置如果服务和网络连接正常，我们还需要检查防火墙设置。确保 SQL Server 所使用的端口（默认是 1433 对于 TCP&#x2F;IP）已被允许通过防火墙。 代码示例（Windows 防火墙配置）在命令提示符中使用以下命令允许 1433 端口： 12netsh advfirewall firewall add rule name=&quot;SQL Server Port 1433&quot; dir=in action=allow protocol=TCP localport=14331. 6. 使用 SQLCMD 测试连接可以使用 SQL Server 提供的 SQLCMD 工具来测试连接，以确保连接字符串的正确性。 代码示例12sqlcmd -S 192.168.1.100 -U myUsername -P myPassword1. 如果连接成功，则会提示 入 SQL 命令。 7. 错误日志如果以上步骤仍未解决问题，可以查阅 SQL Server 错误日志。错误日志通常可以在 SQL Server Management Studio 的“管理”部分找到。 代码示例查看错误日志的 SQL 语句： 登录后复制 1EXEC xp_readerrorlog;","categories":[{"name":"编程技术","slug":"编程技术","permalink":"https://exder145.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://exder145.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"EXDER"},{"title":"爬虫环境配置总结","slug":"Crawl4AI爬虫","date":"2024-12-23T16:00:00.000Z","updated":"2024-12-26T05:23:26.728Z","comments":true,"path":"2024/12/24/Crawl4AI爬虫/","link":"","permalink":"https://exder145.github.io/2024/12/24/Crawl4AI%E7%88%AC%E8%99%AB/","excerpt":"记录一下配置和学习 Crawl4AI 爬虫工具中遇到的问题，以便日后查阅。","text":"记录一下配置和学习 Crawl4AI 爬虫工具中遇到的问题，以便日后查阅。 官网：Home - Crawl4AI Documentation 中文教程网站：和 GPT 一起学习全栈技术。 初始环境检查首先需要检查以下几个基础组件: Chrome 浏览器是否正确安装 Python 环境是否配置完成 相关依赖包的版本是否符合要求 这些都是后续操作的基础,如果这一步出现问题会影响到整个配置过程 需要安装以下的包: pip install crawl4ai 其他： Playwright: playwright install chrome 解析器: lxml, html5lib, beautifulsoup4 存在问题在使用官方推荐的测试代码（如下）时，出现 lxml 解析器无法正常使用，chromo 无法使用等问题。 1234567891011121314import asynciofrom crawl4ai import AsyncWebCrawlerasync def main(): # Create an instance of AsyncWebCrawler async with AsyncWebCrawler(verbose=True) as crawler: # Run the crawler on a URL result = await crawler.arun(url=&quot;https://www.nbcnews.com/business&quot;) # Print the extracted content print(result.markdown)# Run the async main functionasyncio.run(main()) lxml 解析器问题处理步骤： 首先卸载现有的 lxml： 1pip uninstall lxml 然后重新安装所需的所有解析器： 123pip install lxmlpip install html5libpip install beautifulsoup4 随后测试，显示所有基本依赖都已正确安装。 Chrome 无法使用（半解决）根据报错内容，发现错误信息显示：找不到 Chrome 浏览器，更换为本地完整路径也无效 解决方法：重新安装 Playwright 的 Chrome 浏览器 注：本地 chrome 浏览器与 Playwright 的 Chrome 浏览器并非同一个！ 12# 安装 Playwright 的 Chromeplaywright install chrome 验证 Playwright 的 Chrome 是否安装成功： 12playwright --versionplaywright show-browsers 原因： Playwright 的工作方式 Playwright 使用自己管理的浏览器版本，而不是系统安装的 Chrome 这样做是为了确保跨平台兼容性和版本控制 即使已经安装了 Chrome，Playwright 也需要安装自己的版本 为什么要这样做？ 版本控制：确保代码在所有环境中都能正常运行 隔离性：避免与系统浏览器的配置冲突 自动化控制：更好地支持自动化测试和爬虫功能 但悲伤的是，经测试其他爬虫方法都可以正常使用 Chrome，唯独在使用 Crawl4AI 时 Chrome 死活连 �� 不上。在挣扎了二十分钟后终于屈服了，换为了火狐浏览器完美解决 官网给出的测试代码： （默认为 chrome） 1234567891011121314import asynciofrom crawl4ai import AsyncWebCrawlerasync def main(): # Create an instance of AsyncWebCrawler async with AsyncWebCrawler(verbose=True) as crawler: # Run the crawler on a URL result = await crawler.arun(url=&quot;https://www.nbcnews.com/business&quot;) # Print the extracted content print(result.markdown)# Run the async main functionasyncio.run(main()) 运行后报错： 12345678910111213141516171819202122232425262728293031323334353637383940414243Traceback (most recent call last): File &quot;c:\\Users\\EXDER\\Desktop\\test\\crawl_test.py&quot;, line 14, in &lt;module&gt; asyncio.run(main()) File &quot;E:\\python\\Lib\\asyncio\\runners.py&quot;, line 194, in run return runner.run(main) ^^^^^^^^^^^^^^^^ File &quot;E:\\python\\Lib\\asyncio\\runners.py&quot;, line 118, in run return self._loop.run_until_complete(task) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File &quot;E:\\python\\Lib\\asyncio\\base_events.py&quot;, line 687, in run_until_complete return future.result() ^^^^^^^^^^^^^^^ File &quot;c:\\Users\\EXDER\\Desktop\\test\\crawl_test.py&quot;, line 6, in main async with AsyncWebCrawler(verbose=True, browser_type=&#x27;chrome&#x27;) as crawler: File &quot;E:\\python\\Lib\\site-packages\\crawl4ai\\async_webcrawler.py&quot;, line 131, in __aenter__ await self.crawler_strategy.__aenter__() File &quot;E:\\python\\Lib\\site-packages\\crawl4ai\\async_crawler_strategy.py&quot;, line 500, in __aenter__ await self.start() File &quot;E:\\python\\Lib\\site-packages\\crawl4ai\\async_crawler_strategy.py&quot;, line 507, in start await self.browser_manager.start() File &quot;E:\\python\\Lib\\site-packages\\crawl4ai\\async_crawler_strategy.py&quot;, line 290, in start self.browser = await self.playwright.chromium.launch(**browser_args) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File &quot;E:\\python\\Lib\\site-packages\\playwright\\async_api\\_generated.py&quot;, line 14404, in launch await self._impl_obj.launch( File &quot;E:\\python\\Lib\\site-packages\\playwright\\_impl\\_browser_type.py&quot;, line 95, in launch Browser, from_channel(await self._channel.send(&quot;launch&quot;, params)) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File &quot;E:\\python\\Lib\\site-packages\\playwright\\_impl\\_connection.py&quot;, line 61, in send return await self._connection.wrap_api_call( ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File &quot;E:\\python\\Lib\\site-packages\\playwright\\_impl\\_connection.py&quot;, line 528, in wrap_api_call raise rewrite_error(error, f&quot;&#123;parsed_st[&#x27;apiName&#x27;]&#125;: &#123;error&#125;&quot;) from Noneplaywright._impl._errors.Error: BrowserType.launch: Chromium distribution &#x27;chrome&#x27; is not found at C:\\Users\\EXDER\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exeRun &quot;playwright install chrome&quot;Exception ignored in: &lt;function BaseSubprocessTransport.__del__ at 0x00000216290ECE00&gt;Traceback (most recent call last): File &quot;E:\\python\\Lib\\asyncio\\base_subprocess.py&quot;, line 126, in __del__ File &quot;E:\\python\\Lib\\asyncio\\base_subprocess.py&quot;, line 104, in close File &quot;E:\\python\\Lib\\asyncio\\proactor_events.py&quot;, line 109, in close File &quot;E:\\python\\Lib\\asyncio\\base_events.py&quot;, line 795, in call_soon File &quot;E:\\python\\Lib\\asyncio\\base_events.py&quot;, line 541, in _check_closedRuntimeError: Event loop is closed 修改为火狐浏览器： 1async with AsyncWebCrawler(verbose=True, browser_type=&#x27;firefox&#x27;) as crawler: 终于出现了正确的输出： 123456789[INIT].... → Crawl4AI 0.4.22[FETCH]... ↓ https://www.example.com/... | Status: True | Time: 0.02s[SCRAPE].. ◆ Processed https://www.example.com/... | Time: 2ms[COMPLETE] ● https://www.example.com/... | Status: True | Total: 0.03s# Example DomainThis domain is for use in illustrative examples in documents. You may use this domain in literature without prior coordination or asking for permission.[More information...](https://www.iana.org/domains/example) 但最奇怪的是，后续我尝试了 edge，safari 等浏览器，都显示无法正常运行，报错同上。似乎只有火狐可以。到底是什么原理呢。。。","categories":[{"name":"编程技术","slug":"编程技术","permalink":"https://exder145.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://exder145.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://exder145.github.io/tags/%E7%88%AC%E8%99%AB/"}],"author":"EXDER"},{"title":"ARIES算法","slug":"ARIES算法","date":"2024-12-06T16:00:00.000Z","updated":"2024-12-30T12:50:54.380Z","comments":true,"path":"2024/12/07/ARIES算法/","link":"","permalink":"https://exder145.github.io/2024/12/07/ARIES%E7%AE%97%E6%B3%95/","excerpt":"基于 undo&#x2F;redo 日志的恢复算法缺陷、ARIES 优化策略、脏页表作用、活跃事务表和 PrevLSN","text":"基于 undo&#x2F;redo 日志的恢复算法缺陷、ARIES 优化策略、脏页表作用、活跃事务表和 PrevLSN ARIES 介绍ARIES（Algorithm for Recovery and Isolation Exploiting Semantics）是数据库管理系统中一种先进的数据恢复算法，专门用来在系统崩溃后确保数据的一致性和完整性。ARIES 的设计旨在解决传统 undo&#x2F;redo 日志机制中的一些缺陷，使得数据恢复更高效、更可靠。 ARIES 算法的核心思想和目标ARIES 的主要目标是： 支持故障恢复：在系统崩溃后，可以将数据库恢复到最近的一致状态。 保持高效：减少恢复时间，提高系统整体性能。 支持并发：允许多个事务并发运行，同时能有效处理事务间的数据冲突和依赖。 ARIES 的主要组件ARIES 算法引入了几个关键数据结构和机制： 日志（Log）：记录事务的每一步操作。日志包含了操作类型、数据页的变化情况等信息，便于恢复时进行 redo 或 undo。 脏页表（Dirty Page Table, DPT）：记录自上次检查点以来被修改过但尚未写回磁盘的数据页。DPT 使得系统在恢复时可以直接找到哪些数据需要 redo，从而节省了恢复时间。 活跃事务表（Active Transaction Table, ATT）：记录当前活跃的事务及其状态，用于追踪哪些事务未提交，以便在恢复时进行适当的 undo 操作。 PrevLSN（Previous Log Sequence Number）：在日志链中每条记录包含指向上一个日志条目的指针，方便在回滚时倒序查找。 ARIES 的三阶段恢复流程ARIES 的恢复过程可以分为以下三个阶段： 分析阶段（Analysis）： 通过读取日志和检查点来恢复 DPT 和 ATT，从而确定哪些页面需要 redo、哪些事务需要 undo。 此阶段生成恢复的“路线图”，记录哪些页面是脏页、哪些事务尚未提交等信息。 重做阶段（Redo）： 根据 DPT 和日志内容，重做自上次检查点以来的所有必要操作，确保所有数据页都恢复到崩溃前的最新状态。 Redo 仅作用于需要更新的页面，避免无效的操作，从而提升了恢复效率。 回滚阶段（Undo）： 根据 ATT 回滚所有未完成的事务，通过反向应用日志中的 undo 记录，确保未提交事务的操作被撤销。 使用 PrevLSN 跟踪并执行回滚的顺序，避免事务间相互干扰。 ARIES 算法的优化策略为了进一步提高恢复效率，ARIES 在传统的日志机制上做了优化，包括： 检查点机制：通过设置检查点，减少恢复时需要分析的日志条数，缩短了恢复时间。 精确的 Redo 操作：通过 DPT 仅针对脏页进行 redo，避免重复操作。 并发事务处理：利用日志中的 PrevLSN、ATT 等信息，确保多个事务可以并发进行，并且即使出现崩溃也能保证一致性。 传统 undo&#x2F;redo传统的 undo&#x2F;redo 日志机制是一种数据库事务管理和恢复技术，用于在数据库系统发生故障或崩溃时确保数据的一致性和完整性。它通过记录事务操作的“前镜像”（before image）和“后镜像”（after image）来支持数据库的恢复。传统的 undo&#x2F;redo 日志机制包括以下两个部分： 1. Undo 日志 定义：Undo 日志记录事务更改之前的数据状态（即“前镜像”），用于在事务回滚时恢复数据到事务执行前的状态。 工作方式：在事务对数据页进行任何更改前，数据库会将该数据页的原始状态记录到日志中。 作用：当事务失败或系统崩溃时，数据库可以使用 Undo 日志将所有已开始但未提交的事务操作回滚（撤销），恢复到一致的状态。 示例：假设事务 T1 将数据项 A 的值从 10 改为 20，那么数据库在执行更改前会记录“将 A 从 10 改为 20”的 undo 日志条目。当 T1 失败时，系统可以利用 undo 日志将 A 的值恢复为 10。 2. Redo 日志 定义：Redo 日志记录事务更改之后的数据状态（即“后镜像”），用于在系统崩溃后重新应用已提交的事务。 工作方式：在事务完成并提交后，数据库会将修改后的新值写入 Redo 日志，以便在恢复过程中重复这些操作。 作用：在系统崩溃后，数据库通过 Redo 日志重新执行已提交的操作，以确保所有提交的事务操作得到反映，保持数据库一致性。 示例：如果事务 T1 已提交并将数据项 B 从 15 改为 25，Redo 日志会记录“将 B 的值改为 25”。系统重启时，即使 B 的数据页没有被写入磁盘，系统也可以通过 Redo 日志将 B 恢复到 25。 传统 undo&#x2F;redo 日志机制的恢复流程当系统崩溃时，传统的 undo&#x2F;redo 机制按以下步骤恢复数据： 检查提交状态：确定在崩溃发生前，哪些事务已提交、哪些未提交。 Undo 操作：对未提交的事务执行 Undo 操作，将数据恢复到其初始状态，确保未完成的事务对数据库无影响。 Redo 操作：对已提交的事务执行 Redo 操作，确保所有已提交的事务在系统中得到持久化应用。 传统 undo&#x2F;redo 日志机制的缺陷传统的 undo&#x2F;redo 机制虽然简单，但也存在一些限制和缺陷： 恢复效率低下：恢复过程中需要扫描所有日志条目来确认哪些需要 redo 或 undo，特别是在没有检查点优化时效率较低。 对并发事务支持不足：无法有效处理多个事务并发写入的复杂情况，容易导致资源竞争或数据一致性问题。 未优化的数据恢复：在 redo 阶段可能会对不需要恢复的数据页重复执行操作，增加了恢复时间。 总结传统 undo&#x2F;redo 机制作为一种基本的数据恢复方法，在简单的单一事务环境下能提供数据一致性保障，但在复杂系统和高并发场景下则难以高效应对。因此，ARIES 等优化算法被引入，以改善恢复效率并支持更高的并发性。 ARIES 相较于 undotodo1. 恢复效率更高 脏页表（Dirty Page Table, DPT）：ARIES 使用脏页表记录哪些页面被修改但尚未写回磁盘。在恢复时，只需要针对这些脏页执行 redo 操作，避免了对所有日志条目的扫描，提高了恢复效率。 检查点机制：通过周期性地创建检查点，ARIES 在恢复时可以从最近的检查点开始分析，而无需从日志的起点读取，进一步缩短了恢复时间。 2. 精确的 Redo 和 Undo 操作 Selective Redo：ARIES 中的 Redo 阶段只针对那些确实需要重做的页面和数据，避免了重复执行不必要的 redo 操作，从而提升了恢复的精确性和效率。 逻辑回滚（Logical Undo）：ARIES 采用逻辑回滚机制，通过 PrevLSN 指针将未完成的事务逐步回滚，能够精确追踪并恢复崩溃时的状态，确保数据的一致性。 3. 更强的并发支持 活跃事务表（Active Transaction Table, ATT）：记录所有活跃的事务及其状态，使系统能够有效处理多个事务并发操作。ARIES 通过 ATT 管理事务的顺序和依赖关系，确保事务间不产生冲突，提高了并发事务的处理效率。 日志链（Log Chain）：每条日志记录包含指向前一条记录的 PrevLSN 指针，使得事务在回滚时可以快速访问相关日志记录，从而避免事务之间相互干扰。 4. 灵活的恢复流程 三阶段恢复（Analysis, Redo, Undo）：ARIES 在恢复流程中采用“分析（Analysis）、重做（Redo）、回滚（Undo）”三阶段，分别负责生成恢复策略、确保已提交的数据持久化、以及撤销未完成的事务。这种分阶段恢复方式可以根据实际情况灵活执行各个操作，适应性更强。 支持细粒度恢复：ARIES 在日志中记录了各个页面的更改时间、状态等信息，可以在恢复过程中根据细粒度的日志内容精准恢复，避免无关页面的恢复操作。 5. 优化的事务一致性保障 分离的 Undo 和 Redo 操作：ARIES 的设计保证了即使在系统崩溃时，redo 和 undo 操作可以分离处理，不会产生冲突。因此即使事务失败或崩溃，系统也能保持一致性。 避免级联回滚：由于 ARIES 能够精确地管理和恢复各个事务的状态，减少了事务相互影响，避免了传统方法中可能产生的级联回滚问题（即一个事务的回滚导致其他相关事务也需要回滚）。 脏页表脏页表（Dirty Page Table, DPT）是数据库系统中的一个重要数据结构，用于记录哪些内存页面在上次检查点之后被修改但尚未写回磁盘。它的主要作用包括： 1. 跟踪修改的页面 脏页表记录了自上次检查点以来被修改过的所有数据页。这意味着，系统可以快速识别哪些页面需要进行重做（redo）操作，而不需要扫描所有数据页。 2. 提高恢复效率 在数据恢复过程中，系统只需针对脏页表中列出的页面进行重做。这大大减少了需要处理的页面数量，从而加快了恢复速度。 3. 避免不必要的 IO 操作 由于只处理脏页，脏页表帮助减少了不必要的磁盘写入和读取操作，优化了系统性能。 4. 支持高并发事务 在高并发环境中，脏页表帮助管理多个事务对页面的修改，确保系统能够有效地处理并发操作并保持一致性。 总结脏页表在 ARIES 算法和其他现代数据库恢复机制中扮演着重要角色，通过精确跟踪被修改的数据页，提升了恢复效率和系统性能。 1. 刷回磁盘（Flush to Disk） 定义：将内存中的数据（如缓存或脏页）写入到永久存储设备（如硬盘）中。 作用：确保数据的持久性。当系统崩溃或断电时，内存中的数据可能会丢失，因此将其刷回磁盘可以确保数据不会丢失。 上下文：在数据库系统中，当事务提交后，通常会将该事务修改的数据刷回磁盘，以确保这些更改被永久保存。 2. 重做（Redo） 定义：在系统恢复过程中，将已提交事务的修改操作重新应用到数据库中，以确保这些更改在崩溃后依然存在。 作用：确保所有已提交的事务的结果都被持久化，尤其是在系统崩溃后重新启动时。 上下文：在 ARIES 算法中，重做操作是恢复过程的一部分，系统会根据脏页表和日志信息，重新执行必要的操作，以恢复数据到最新状态。 3. 回滚（Undo） 定义：撤销未完成或未提交事务的操作，将数据恢复到事务开始之前的状态。 作用：确保数据库的一致性，避免未提交事务的操作影响到其他事务。 上下文：在 ARIES 算法中，回滚是恢复过程中处理未完成事务的一步。 检查点在数据库系统中，检查点（Checkpoint）是一种机制，用于定期保存数据库的当前状态，以加速系统崩溃后的恢复过程。检查点通过将一些数据和日志信息写入磁盘，使得恢复算法在崩溃时可以从最近的检查点开始，而不是从日志的开头扫描，大大减少了恢复时间。 检查点的工作方式检查点操作通常包括以下步骤： 暂停部分事务操作：在开始检查点时，系统会暂停新的写操作，确保数据的一致性。 记录活跃事务表（ATT）和脏页表（DPT）：系统记录当前活跃的事务和自上次刷入磁盘以来被修改的脏页。 将脏页刷入磁盘：将脏页表中的数据页写入磁盘，以便在崩溃时不需要重做这些修改。 创建检查点记录：系统在日志中写入检查点记录，包含活跃事务表和脏页表的信息。 检查点的作用 减少恢复时间：在崩溃时，系统可以从最近的检查点恢复，而不是遍历整个日志文件。 确保数据一致性：通过记录活跃事务和脏页信息，检查点有助于维持系统的原子性和一致性。 优化性能：通过批量将脏页写入磁盘，检查点减少了频繁的写操作，提高了系统的整体性能。 模糊检查点（Fuzzy Checkpoint）为了不影响系统的运行性能，有些数据库系统采用“模糊检查点”策略，即在创建检查点时允许其他事务继续运行，避免完全暂停写操作。这种方法确保在系统高负载时也能创建检查点，从而保持数据恢复能力。 lsnLSN（Log Sequence Number，日志序列号）是数据库系统中用于标识日志记录的唯一编号。每条日志记录都会分配一个 LSN，通常以递增的顺序生成。LSN 在数据库的恢复、检查点和事务管理中发挥着关键作用。 LSN 的作用 标记日志顺序：每条日志记录都有一个独特的 LSN，表示它在日志中的位置或顺序。这样可以准确跟踪每条记录的写入顺序。 支持恢复操作：在数据库恢复过程中，系统可以利用 LSN 来确定哪些数据页需要重做（Redo）或回滚（Undo）。只要有 LSN 的记录，系统就可以根据其顺序，决定执行的恢复操作。 维护数据一致性：每个数据页也会记录一个与之关联的 LSN，称为 pageLSN。通过对比数据页的 pageLSN 和日志中的 LSN，系统可以判断该页是否已经同步到最新状态。 常见的 LSN 类型 flushedLSN：指示已写入磁盘的最大 LSN，用于判断哪些日志记录已经被安全地写入磁盘。 pageLSN：记录在数据页上的最新更新 LSN，用于判断该页是否需要更新。 lastLSN：指每个事务的最后一条日志记录的 LSN，便于追踪事务状态。 recLSN：脏页表中的一个字段，指示导致该页变脏的第一条日志记录的 LSN，用于确定需要 redo 的最早位置【35†source】【36†source】。 总结LSN 通过唯一标识和顺序控制，为数据库的故障恢复、事务一致性和检查点维护提供了基础保障。 举例说明（插入 ppt场景假设数据库在处理多个事务时崩溃了。我们在重启时会进入恢复过程，为了恢复数据库到崩溃前的状态，需要依靠日志记录来重做（redo）某些事务操作。而“脏页表”（Dirty Page Table, DPT）是帮助我们判断哪些页面需要重做的一个关键工具。 1. 什么是脏页和脏页表？ 脏页：脏页是指曾被修改过但修改尚未写回磁盘的数据页。假设数据库某条数据被修改后只保存在内存中，尚未存入磁盘，那么这个数据页就叫“脏页”。 脏页表：脏页表在崩溃时刻记录了哪些页是脏的。每个脏页都有一个 RecLSN（最早的日志序列号，指的是该页从什么时候开始变“脏”），用于帮助判断页面的状态。 在恢复过程中，脏页表的作用是：只需要对脏页进行重做，因为只有它们可能包含未写回磁盘的最新修改。 2. 日志记录的 pageID 不在脏页表中，不需要重做这是判断重做需求的第一个条件： 如果某条日志记录指向的 pageID（页面编号）不在脏页表中，说明这条记录的修改已经写入了磁盘。这是因为，只有未写入磁盘的修改才会导致页面被标记为“脏页”并记录在脏页表中。 因此，如果 pageID 不在脏页表里，这条日志记录的修改已经被安全地保存到磁盘了，不需要再重做。 比方说：假设日志记录写着“pageID 3 被更新了”，但崩溃时 pageID 3 不在脏页表中，说明 pageID 3 的更新已经在崩溃前成功写入磁盘，因此不需要对它重做。 3. 日志记录 LSN &lt;= RecLSN，数据修改已在磁盘页面号 RecLSN 生效，不需要重做这是判断重做需求的第二个条件，关注 LSN 和 RecLSN 的比较： LSN：日志的唯一标识，每条日志记录的 LSN 都会比前一条更大，用来确保恢复操作按正确的顺序执行。 RecLSN：脏页表中每个页面记录的 RecLSN，是指该页面自崩溃前最早一次“变脏”时的 LSN，也就是该页面从这个 RecLSN 开始进入了“脏”状态。 判断依据： 如果某条日志记录的 LSN **小于等于 RecLSN**，说明这条记录的修改在页面变脏时就已经写入磁盘了。 因此，不需要再对这条日志记录重做，因为崩溃前它已经生效了。 比方说：假设 pageID 5 在脏页表中的 RecLSN 是 50，这表示从 LSN 50 开始，这个页面的数据变得不一致了（脏了）。如果我们遇到一个日志记录的 LSN 是 30（小于等于 50），那么这条记录的数据在页面变脏之前就已经在磁盘上生效了，不需要再重做这条记录的操作。 总结在重做过程中： 如果日志记录的 pageID 不在脏页表中，则不需要重做这条日志记录。 **如果日志记录的 LSN &lt;= RecLSN**，说明这条记录对应的数据已经在崩溃前写入了磁盘，也不需要重做。 这两个条件帮助数据库系统节省了恢复时间，只对那些未保存到磁盘的、重要的日志记录进行重做，从而高效恢复到一致的状态。 是的，崩溃后内存中的脏页表会消失，因为内存数据在系统崩溃或断电时无法保留。这也是为什么数据库系统需要定期将 脏页表的快照（checkpoint）写入磁盘，以便在崩溃后恢复时可以使用。 崩溃恢复过程中脏页表的作用 检查点（Checkpoint）： 数据库系统会定期创建检查点，将当时的脏页表以及相关的事务状态记录（如活动事务表）持久化到磁盘。 检查点中的脏页表记录了到检查点时为止的所有脏页及其 RecLSN。在崩溃恢复时，这个信息用于判断从哪里开始重做。 崩溃后的恢复： 恢复过程会首先加载最近的检查点状态，获取当时的脏页表，然后根据检查点后的日志记录继续恢复。 这样，即使内存中的脏页表因崩溃而丢失，系统也能从检查点提供的“历史” DPT 状态中找到需要重做的页面范围。 恢复过程示例 重做（Redo）阶段：系统会从检查点的 DPT 开始，扫描检查点之后的日志，找出并重做所有需要更新的数据页。 避免重复重做：通过检查点中的 DPT 和日志中的 LSN，可以准确找到从哪开始恢复，避免不必要的重复操作。 总结由于崩溃会导致内存中的 DPT 消失，数据库系统通过 定期检查点将 DPT 持久化到磁盘。在崩溃恢复时，系统利用检查点保存的 DPT 来重新构建需要重做的页面信息，从而有效地完成恢复操作。 p79 RecLSN：脏页表中每个页面记录的 RecLSN，是指该页面自崩溃前最早一次“变脏”时的 LSN，也就是该页面从这个 RecLSN 开始进入了“脏”状态。 所以不需要将 c 4 改为 c 6 补偿日志补偿日志记录（CLR，Compensation Log Record） 是数据库在执行 ARIES 恢复算法 时生成的一种特殊日志记录，用于在回滚操作中记录撤销的操作。它的主要作用是保证系统在执行回滚时具有可恢复性，并避免回滚操作重复执行。 补偿日志的作用补偿日志的核心目的是确保数据库能够 安全地回滚事务，即使在回滚的过程中再次发生系统崩溃。补偿日志通过记录每个撤销的步骤，使得系统在恢复时可以识别哪些操作已经撤销，以防止重复执行相同的撤销。 补偿日志的关键内容每条补偿日志包含的信息通常包括： 被撤销的日志记录的 LSN：指向要撤销的原始日志记录，方便找到回滚的操作。 撤销操作的影响：记录被回滚操作的反向效果，用于确保数据回到修改前的状态。 NextUndoLSN：指向下一个需要撤销的日志记录，用于链式回滚。如果崩溃发生在回滚过程中，恢复过程可以从 NextUndoLSN 开始继续回滚。 补偿日志的工作原理在执行回滚时，数据库会按照 从后往前 的顺序逐条撤销操作。当撤销某条日志记录时，系统会生成一条补偿日志，将撤销的内容和 NextUndoLSN 记录下来。这样，即使在回滚的过程中再次崩溃，系统在重启后也可以通过补偿日志记录，继续从上次回滚的进度开始，避免重复回滚已经撤销的操作。 示例假设我们有一个事务 T1，执行了以下操作： 写操作 1：修改了 Page A（LSN &#x3D; 100）。 写操作 2：修改了 Page B（LSN &#x3D; 150）。 事务失败或被用户取消：系统开始回滚。 在回滚过程中： 系统会先撤销 写操作 2，并生成一条补偿日志 CLR1（指向 LSN &#x3D; 150 的操作）。 接着，系统会撤销 写操作 1，生成另一条补偿日志 CLR2（指向 LSN &#x3D; 100 的操作）。 如果在回滚的过程中发生崩溃，再次恢复时系统会查看这些补偿日志，确定哪些撤销操作已经完成，哪些尚未完成，从而继续回滚未完成的部分。 总结 补偿日志记录 是数据库在回滚时生成的日志，确保在回滚过程中崩溃依然可以恢复，避免重复回滚。 CLR 的重要性 在于提供了一种“防重复”机制，即使发生崩溃，系统依然能够继续完成回滚操作，保持数据一致性。","categories":[{"name":"编程技术","slug":"编程技术","permalink":"https://exder145.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://exder145.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"EXDER"},{"title":"verilog笔记","slug":"verilog笔记","date":"2024-10-26T16:00:00.000Z","updated":"2024-12-30T12:13:06.297Z","comments":true,"path":"2024/10/27/verilog笔记/","link":"","permalink":"https://exder145.github.io/2024/10/27/verilog%E7%AC%94%E8%AE%B0/","excerpt":"之前写的 verilog 笔记，记得很混乱，但还是传一下吧","text":"之前写的 verilog 笔记，记得很混乱，但还是传一下吧 数据类型基本模块: 123456789101112module 模块名 ( // 端口定义之间用英文逗号 , 分隔开 输入端口定义, // 输入端口只能是 wire 类型 输出端口定义 // 输出端口可以根据需要定义为 wire 或 reg 类型); // 不要忘记这里的分号 内部信号定义语句 // 内部信号可以根据需要定义为 wire 或 reg 类型 //wire型可省略 模块实例化语句 // 将其他模块接入电路 assign 数据流赋值语句 always 过程赋值语句endmodule 线网（wire）wire 类型表示硬件单元之间的物理连线，由其连接的器件输出端连续驱动。如果没有驱动元件连接到 wire 型变量，缺省值一般为 “Z”。举例如下： 实例 123wire interrupt ;wire flag1, flag2 ;wire gnd = 1&#x27;b0 ; 线网型还有其他数据类型，包括 wand，wor，wri，triand，trior，trireg 等。这些数据类型用的频率不是很高，这里不做介绍。 寄存器（reg）寄存器（reg）用来表示存储单元，它会保持数据原有的值，直到被改写。声明举例如下： 实例 12reg clk_temp;reg flag1, flag2 ; 例如在 always 块中，寄存器可能被综合成边沿触发器，在组合逻辑中可能被综合成 wire 型变量。寄存器不需要驱动源，也不一定需要时钟信号。在仿真时，寄存器的值可在任意时刻通过赋值操作进行改写。例如： 实例 123456reg rstn ;initial begin rstn = 1&#x27;b0 ; #100 ; rstn = 1&#x27;b1 ;end wire 和 reg 的区别1.wire 和 reg 的本质wire 的本质是一条没有逻辑的连线，也就是说输入时什么输出也就是什么。wire 型数据常用来表示以 assign 关键字指定的组合逻辑信号，模块的输入输出端口类型都默认为 wire 型，wire 相当于物理连线，默认初始值是 z（高组态）。如果你把 wire 定义的变量用在有逻辑性的语句中就会出现综合错误：例如：在 always 语句中使用 wire 型定义的变量赋值，综合器就会报错。 reg 型表示的寄存器类型，用于 always 模块内被赋值的信号，必须定义为 reg 型，代表触发器，常用于时序逻辑电路，reg 相当于存储单元，默认初始值是 x（未知状态）。reg 型相对复杂些，其综合后的输出主要还看具体使用的场景：当在组合电路中使用 reg，合成后的仍然是 net 网络；当在时序电路中使用 reg 合成后的才是 register。 2.wire 和 reg 在硬件描述语言中的释义关于 wire 和 reg 在硬件描述语言中的释义一般需要分为以下两个部分来分析：从电路综合角度来说（1）wire 型变量综合出来是一根导线（2）reg 型在 always 语句模块中又分为两种情况(a) always 后的敏感表中是（a or b or c）形式的，也就是不带时钟边沿的，综合出来还是组合逻辑(b) always 后的敏感表中是（posedge clk）形式的，也就是带边沿的，综合出来一般是时序逻辑，会包含触发器（Flip－Flop） 在设计中，输入信号一般来说你是不知道上一级是寄存器输出还是组合逻辑输出，那么对于本级来说就是一根导线，也就是 wire 型。而输出信号则由你自己来决定是组合逻辑输出还是寄存器输出，wire 型、reg 型都可以。但一般的，整个设计的外部输出（即最顶层模块的输出），要求是寄存器输出，较稳定、扇出能力也较好。 从仿真分析角度来说wire 对应于连续赋值，如 assignreg 对应于过程赋值，如 always，initial 3.使用 wire 的情况（1）assign 语句中变量需要定义成 wire 型例如： 1234reg a,b;wire result;…assign result =a&amp;&amp;b; （2）元件例化时候的输出必须用 wire例如： 12345678wire dout;ram u_ram(….out(dout)…); （3）input、output 和 inout 的预设值都是 wire input、inout 类型的端口不能声明为 reg 数据类型，因为 reg 类型常用于保存数值，而输入端口只反映与其相连的外部信号的变化，不应保存这些信号的值。output 类型的端口则可以声明为 wire 或 reg 数据类型。 wire 型为默认数据类型，因此当端口为 wire 型时，不用再次声明端口类型为 wire；但是当端口为 reg 型时，对应的 reg 声明不可省略。 整数（integer）整数类型用关键字 integer 来声明。声明时不用指明位宽，位宽和编译器有关，一般为 32 bit。reg 型变量为无符号数，而 integer 型变量为有符号数。 综合后实际电路里并没有 k这个信号 k只是辅助生成相应的硬件电路。 状态机**FSM **FSM 的概念 注意到电路中存在一个名为状态寄存器的特殊结构，该结构存储了电路当前的状态信息。设寄存器位宽为 n，则该电路的状态数量不会超过 2 的 n 次方，即其状态数量是有限的，因此这种电路结构称为有限状态机（FSM）。 顾名思义，有限状态机就是由一系列数量有限的状态组成的循环机制。它是由寄存器和组合逻辑构成的硬件时序电路。状态机通过控制各个状态的跳转来控制流程，使得整个代码看上去更加清晰易懂，在控制复杂流程的时候，状态机有着明显的设计优势。 设计 FSM（1）画出状态转移图 把实际系统进行逻辑抽象，即实际问题转化为设计要求。首先确定电路输入输出引脚；然后根据实际需要列出所有的状态情况，并对状态顺序进行编号；最后根据状态转移条件画出状态转移图。 （2）确定状态编码和编码方式 编码方式的选择对所设计的电路复杂与否起着重要作用，要根据状态数目确定状态编码和编码方式。 （3）给出状态方程和输出方程 列写状态转移表，选定触发器类型，通过卡诺图化简给出状态方程和输出方程。（此步在 FPGA 编程中可省略） （4）编写 Verilog 代码 按照步骤（1）~（2）编写具有可综合的 Verilog 代码。 状态机分类：moore 和 mealy Moore：输出信号只与现态有关，输入信号不会直接影响到输出信号，而是与当前状态（简称现态）信号一起生成下一状态（简称次态）信号，在时钟的上升沿之后次态转换为现态，才能影响到输出 Mealy：输出信号由现态与输入信号共同生成，输入信号可立刻对输出信号产生影响 两种结构的有限状态机各有优缺点：Moore 型时序更好，但响应要慢一拍，Mealy 型响应最快，但时序上要差一些。一般来说，如果对电路相应速度要求不是非常苛刻的话，推荐使用 Moore 型有限状态机。 FSM 代码实现结构通过分析有限状态机的结构图，我们可以发现其包含三个部分： 第一部分为组合逻辑，通过现态和输入信号生成次态信号。 第二部分为时序逻辑，包含一个带有复位功能的寄存器单元，复位时现态信号变为初始值，否则在每个时钟的上升沿将次态信号赋值给现态信号。 第三部分为组合逻辑，该部分通过现态信号生成各输出信号。 其对应的代码结构为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071module FSM ( input clk, input rst, // ...... // 其他输入输出信号);// 状态空间位数 nparameter WIDTH = 3;// 状态变量reg [WIDTH-1: 0] current_state, next_state;// 为了便于标识，我们用局部参数定义状态的别名代替状态编码localparam STATE_NAME_1 = 3&#x27;d0;localparam STATE_NAME_2 = 3&#x27;d1;// ......// ==========================================================// Part 1: 使用同步时序进行状态更新，即更新 current_state 的内容。// ==========================================================always @(posedge clk) begin // 首先检测复位信号 if (rst) current_state &lt;= RESET_STATE; // 随后再进行内容更新 else current_state &lt;= next_state;end// ==========================================================// Part 2: 使用组合逻辑判断状态跳转逻辑，即根据 current_state 与// 其他信号确定 next_state。// ==========================================================// 一般使用 case + if 语句描述跳转逻辑always @(*) begin // 先对 next_state 进行默认赋值，防止出现遗漏 next_state = current_state; case (current_state) STATE_NAME_1: begin // ...... end STATE_NAME_2: begin // ...... end default: begin // ...... end endcaseend// ==========================================================// Part 3: 使用组合逻辑描述状态机的输出。这里是 mealy 型状态机// 与 moore 型状态机区别的地方。// ==========================================================// 可以直接使用 assign 进行简单逻辑的赋值assign out1 = ......;// 也可以用 case + if 语句进行复杂逻辑的描述always @(*) begin case (current_state) STATE_NAME_1: begin // ...... end STATE_NAME_2: begin // ...... end default: begin // ...... end endcaseendendmodule 一个实例 数字锁 某助教有一个神奇的锁。锁盘上只有两个按键，我们不妨记为 0 和 1。只有按键按照 0100 的顺序按下时才能解锁成功。例如，连续按下 01010 时并不会解锁，但再按下 0 后便会解锁（因为最近的四次输入为 0100）。我们想用一个数字电路判断给定的按键顺序能否解锁。 模块的输入包含一个时钟信号 clk 以及按下的按键编号 in。由于只有两个按键，所以我们可以根据 in 的高低电平区分按下的按键（例如高电平代表按下 1）。在 clk 的上升沿模块接收一个按键信息，同时输出一个 unlock 信号，当 unlock 信号为高电平时表明最近四次输入的序列可以解锁。 首先来考虑如何确定状态。自然，我们可以根据当前最近的四个输入标识状态，则对应的状态共有 24&#x3D;16 种。但包含十六个状态的有限状态机无论设计上还是实现上都较为复杂，尽管我们可以通过状态化简消去一部分，但这个过程依然是十分繁琐的。 让我们再次分析这个问题。对于一个给定的输入序列，想要判断其能否开锁，我们只需要关注其最近的输入能否组成 0100 序列。先前我们固定观察最近的四次输入，但实际上有些情况近期是一定不能解锁的，例如序列 1110 至少要再经过三次输入才有可能解锁。 基于这一事实，我们可以只关注输入序列是否包含 0100 及其子序列，即考察最近的输入内容为 0、01、010、0010 四种情况。我们称之为后缀识别。 在最开始没有任何输入时，我们可以引入一个初始状态（不妨记作 - ），用于代表不属于上述四种的情况。接下来当输入一个 0 时，我们就识别到了后缀 0，即可进入下一状态；若输入一个 1，则不属于任何一种后缀，因此依然在初始状态。以此类推，我们就得到了下图所示的状态机。 构建流程 于是，我们就可以确定下来，这个问题的状态机一共有五个基本状态。我们约定如下的对应关系： S0：对应 - S1：对应 0 S2：对应 01 S3：对应 010 S4：对应 0100 初始状态为 S0，仅在 S4 状态时输出解锁信号。由于输出仅和当前状态有关，因此我们可以选择 Moore 型状态机进行设计。五个状态可以使用 3bits 位宽的编码进行处理。 首先定义状态变量以及状态名称： 123456reg [2:0] current_state, next_state;localparam S0 = 3&#x27;d0;localparam S1 = 3&#x27;d1;localparam S2 = 3&#x27;d2;localparam S3 = 3&#x27;d3;localparam S4 = 3&#x27;d4; 接下来编写第一段：状态更新。假定 reset 信号的效果是清除之前所有的输入，恢复初始状态。则按下 reset 后状态机应当跳转到 S0。 123456always @(posedge clk) begin if (reset) current_state &lt;= S0; else current_state &lt;= next_state;end 接下来编写第二段：状态转移。根据状态转换图，我们可以编写如下的代码： 123456789101112131415161718192021222324252627282930313233343536373839always @(*) begin next_state = current_state; case (current_state) S0: begin // - if (in) next_state = S0; // - else next_state = S1; // 0 end S1: begin // 0 if (in) next_state = S2; // 01 else next_state = S1; // 0 end S2: begin // 01 if (in) next_state = S0; // - else next_state = S3; // 010 end S3: begin // 010 if (in) next_state = S2; // 01 else next_state = S4; // 0100 end S4: begin // 0100 if (in) next_state = S2; // 01 else next_state = S1; // 0 end endcaseend 输出： 1assign unlock = (current_state == S4) ? 1&#x27;B1 : 1&#x27;B0; 课堂笔记 另外的表述方式： 另一个例子： 选择器 优先级编码器 或者: 加法器 全加器结构 其他内容:组合逻辑电路及其 Verilog 实现 latch 的产生和避免锁存器,触发器,寄存器锁存器（Latch），是电平触发的存储单元，数据存储的动作取决于输入时钟（或者使能）信号的电平值。仅当锁存器处于使能状态时，输出才会随着数据输入发生变化。 当电平信号无效时，输出信号随输入信号变化，就像通过了缓冲器；当电平有效时，输出信号被锁存。激励信号的任何变化，都将直接引起锁存器输出状态的改变，很有可能会因为瞬态特性不稳定而产生振荡现象。 锁存器示意图如下： 触发器（flip-flop），是边沿敏感的存储单元，数据存储的动作（状态转换）由某一信号的上升沿或者下降沿进行同步的（限制存储单元状态转换在一个很短的时间内）。 触发器示意图如下： 寄存器（register），在 Verilog 中用来暂时存放参与运算的数据和运算结果的变量。一个变量声明为寄存器时，它既可以被综合成触发器，也可能被综合成 Latch，甚至是 wire 型变量。但是大多数情况下我们希望它被综合成触发器，但是有时候由于代码书写问题，它会被综合成不期望的 Latch 结构。 Latch 的主要危害有： 1）输入状态可能多次变化，容易产生毛刺，增加了下一级电路的不确定性； 2）在大部分 FPGA 的资源中，可能需要比触发器更多的资源去实现 Latch 结构； 3）锁存器的出现使得静态时序分析变得更加复杂。 产生原因 if 结构不完整 case 结构不完整 敏感信号列表不完整 原信号赋值或判断 连续赋值:always 和 initial过程赋值语句用于对 reg 型变量进行赋值，由 2 种关键字引导，分别是 initial 与 always。这两种语句不可嵌套使用，彼此间 并行 执行（执行的顺序与其在模块中的前后顺序没有关系）。如果 initial 或 always 语句内包含多个语句，则需要搭配关键字 begin 和 end 组成一个块语句。 区别每个 initial 语句或 always 语句都会产生一个独立的控制流，执行时间都是从 0 时刻开始。二者的区别在于 : initial 执行一次语句 always 循环执行 格式敏感变量就是触发 always 块内部语句的条件。加入敏感变量后，always 语句仅在列表中的变量发生变化时才执行内部的过程语句。 1234567// 每当 a 或 b 的值发生变化时就执行内部的语句always @(a or b) begin //是的括号里面这东西叫敏感列表 //所有赋值号右边出现的信号都要放到敏感表里 写全避免latch产生 //每个数据连接用 or [过程语句]end 有的时候，敏感列表过多，一个一个加入太麻烦，且容易遗漏。为了解决这个问题，Verilog 2001 标准允许使用符号 * 在敏感列表中表示缺省，编译器会根据 always 块内部的内容自动识别敏感变量。 例如，先前的例子可以写为： 12345reg Cout;wire A, B;always @(*) begin Cout = A &amp; B;end 除了直接使用信号作为敏感变量，Verilog 还支持通过使用 posedge 和 negedge 关键字将电平变化作为敏感变量。其中 posedge 对应上升沿，negedge 对应下降沿。例如：下面的代码仅在 clk 从低电平（0）变为高电平（1）时触发。 123456reg Cout;wire A, B, clk;always @(posedge clk) begin Cout &lt;= A &amp; B;end assign语句中被赋值的信号定义成wire 过程块中被赋值的信号定义成reg (寄存器 可以改变值的变量形式) assign 连续赋值 与物理线不同但十分相似,Verilog 中的线(和其他信号)是有方向的.这意味着信息只在一个方向上流动,从(通常是一个)源流向汇点(源通常也被称为驱动端,将值驱动到 wire 上).在 verilog 的”连续赋值”(assign)中,右侧的信号值被驱动到左侧的”线”上.请注意:赋值是”连续的”,如果右侧的值发生更改,左侧的值将持续随之改变.(这里与其他语言有很大区别).连续赋值不是一次性事件,其赋值功能是永久持续的. 想要真正理解为啥会这样,你首先要明白,你并不是在编写程序,你其实是在用代码”画”电路! 因此输入端的电平高低的变化必然会影响到 wire 的另一端,你可以想像真的有一根电线连接两个变量. 模块(module)上的端口(port)也有方向(通常是输入 – input 或输出 – output).输入端口由来自模块外部的信号驱动,而输出端口驱动外部的信号.从模块内部查看时,输入端口是驱动源,而输出端口是接收器. 下图说明了电路的每个部分如何对应 Verilog 代码的每个部分.模块和端口声明可以创建黑色盒子的电路.你的任务是通过添加一个 assign 语句来创建一条线(绿色).盒子外的部件不需你考虑,但你应该知道,将测试激励连接到 top_module 上的端口可以来测试黑色盒子电路. 下图说明了电路的每个部分如何对应 Verilog 代码的每个部分.模块外部有三个输入端口和四个输出端口. 当您有多个 assign 语句时,它们在代码中的出现顺序并不重要.与编程语言不同,assign 语句(“连续赋值”)描述事物之间的连接,而不是将值从一个事物复制到另一个事物的操作. 可能现在应该澄清的一个潜在的困惑来源是:这里的绿色箭头表示电线之间的连接,但不是 wire 本身.模块本身已经声明了 7 条线(名为 A、B、C、W、X、Y 和 Z).这是因为 input 与 output 被声明为了 wire 类型.因此,assign 语句不会创建 wire,而是描述了在已存在的 7 条线之间创建的连接. Verilog 的三种描述层次 结构化描述方式：调用其他已经定义过的低层次模块对整个电路的功能进行描述，或者直接调用 Verilog 内部预先定义的基本门级元件描述电路的结构进行描述。 数据流描述方式：使用连续赋值语句 assign 对电路的逻辑功能进行描述。该方式特别适合于对组合逻辑电路建模。 行为级描述方式：使用过程块语句结构 always 和比较抽象的高级程序语句对电路的逻辑功能进行描述。 结构化描述方式考虑下图所示的电路： 如果从结构化层面来描述电路，我们需要刻画与门、或门和非门，并将其正确连接。 Verilog 常用的内置逻辑门包括： and（与门） nand（与非门） or（或门） nor（或非门） xor（异或门） xnor（同或门） 我们可以通过类似模块例化的方式使用这些逻辑门，进而实现一些简单的逻辑功能。 下面是使用门级单元结构化描述该电路的 Verilog 代码。 123456789101112131415module MUX2( input a, b, input sel, output out);wire and1, and2, sel_not;and (and1, a, sel_not);and (and2, b, sel);not (sel_not, sel);or (out, and1, and2);endmodule 数据流描述方式数据流描述方式需要我们得到逻辑表达式。可以将门电路转换为对应的逻辑表达式： 1234and (and1, a, sel_not); // and1 = a &amp; sel_notand (and2, b, sel); // and2 = b &amp; selnot (sel_not, sel); // sel_not = ~selor (out, and1, and2); // out = and1 | and2 化简得到输出 out 关于输入 a、b 和 sel 的逻辑表达式： 1out = (a &amp; ~sel) | (b &amp; sel); 由此可以得到基于 assign 语句的数据流描述。 123456789module MUX2( input a, b, input sel, output out);assign out = (a &amp; ~sel) | (b &amp; sel);endmodule 行为级描述方式很多时候，我们难以得到模块的电路结构，或者得到的结构十分繁琐，这时我们就可以使用行为级描述，以类似于高级语言的抽象层次进行硬件结构开发。这一层面的描述过程更看重功能需求与算法实现，也是对于我们最为友好的描述方式。 下面是该电路的行为级描述代码。 12345678910111213module MUX2( input a, b, input sel, output reg out);always @(*) begin if (!sel) out = a; else out = b;endendmodule 数据表示方式","categories":[{"name":"编程技术","slug":"编程技术","permalink":"https://exder145.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://exder145.github.io/tags/verilog/"}],"author":"EXDER"},{"title":"数据结构笔记 -- 排序","slug":"排序","date":"2024-09-29T16:00:00.000Z","updated":"2024-12-30T12:20:26.524Z","comments":true,"path":"2024/09/30/排序/","link":"","permalink":"https://exder145.github.io/2024/09/30/%E6%8E%92%E5%BA%8F/","excerpt":"关于排序知识的整理总结","text":"关于排序知识的整理总结 1.0 基本概念​ 有 n 个记录的序列&#123;R1，R2，…，Rn}，其相应关键字的序列是{K1，K2， …，Kn }，相应的下标序列为1，2，…，n&#96;。 通过排序，要求找出当前下标序列1，2，…， n的一种排列p1，p2， …，pn，使得相应关键字满足如下的非递减（或非递增）关系，即：Kp1≤ Kp2≤…≤ Kpn ，这样就得到一个按关键字有序的记录序列：&#123;Rp1，Rp2， …， Rpn&#125;。 （1）数据表 待排序数组元素的有限集合。 （2）主关键字与次关键字 上面所说的关键字 Ki 可以是记录 i 的主关键字，也可以是次关键字，甚至可以是记录中若干数据项的组合。 若 Ki 是主关键字，则任何一个无序的记录序列经排序后得到的有序序列是唯一的。若 Ki 是次关键字或是记录中若干数据项的组合，得到的排序结果将是不唯一的，因为待排序记录的序列中存在两个或两个以上关键字相等的记录。 （3）内部排序与外部排序 内部排序：整个排序过程不需要访问外存便能完成 外部排序：参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成，需要借助外存 （4）主关键字与次关键字 若两个记录 A 和 B 的关键字值相等，若排序后 A、B 的先后次序保持不变，则称这种排序算法是稳定的，反之称为不稳定的 （5) 逆序 在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。 一个排列中所有逆序的总数叫做这个排列的逆序数。 （6）算法的优劣性 时间效率：排序速度(排序所花费的全部比较次数) 空间效率：占内存辅助空间的大小 稳定性：排序是否稳定 2.0 基本排序方法2.1 冒泡排序算法思想：每趟对所有记录从左到右相邻两个记录进行比较，若不符合排序要求，则进行交换。直到所有相邻元素都满足要求,则算法结束。使用前提必需是顺序存储结构。 时间复杂度: (n−1)+(n−2)+…+1+0&#x3D;n(n−1)&#x2F;2 最坏情况&#x3D;O(n^2) 最好情况:O(N) 空间复杂度: ** 由于算法在执行过程中，只有「交换」变量时候采用了临时变量的方式，而其它没有采用任何的额外空间，所以空间复杂度为O( 1 )**。 算法实现: 123456789101112131415//冒泡排序void BubbleSort(int* arr, int n)&#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125; 代码优化: (1) 减少检验轮数: 通过设置一个交换标志，如果某次循环没有发生交换操作，则说明序列已经有序： 123456789101112131415161718192021 //定义一个标志位，用于判定元素之间是否进行了交换//Boolean 变量存储为 16 位（2 个字节）的数值形式，但只能是 True 或是 False boolean flag = false; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; flag = true; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; if (!flag) &#123; break; &#125; else &#123; //如果发生了交换，那么在下一轮排序之前将flag再次置为false,以便记录下一轮排序的时候是否会发生交换 flag = false; &#125; &#125; (2) 鸡尾酒排序: 冒泡排序算法每一轮都是从左到右进行元素比较，进行单向的位置交换，鸡尾酒排序算法则是双向的元素比较和交换。 例题: 排序以下序列 冒泡排序思想: 由上面可以看出，从 2 到 8 已经是有序了。只有元素 1 的位置不对，却还要进行 7 轮排序。而鸡尾酒算法可以解决这一问题。 鸡尾酒排序: 第一轮 与冒泡排序一致，从左到右进行比较、交换 第二轮 则从右向左进行比较、交换 &gt; 第三轮 没有发生任何元素交换，说明序列已是有序的，排序结束。 代码实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void Cocktail_Sort(int arr[], int sz)&#123; int tmp = 0; int left = 0; int right = sz - 1; for (int i = 0; i &lt; sz / 2; i++) &#123; //有序标记，每一轮的初始是true int flag = 1; //奇数轮，从左向右比较和交换 for (int j = 0; j &lt; sz - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; //有元素交换，所以不是有序，标记变为0 flag = 0; &#125; &#125; if (flag) break; //偶数轮之前，重新标记为1 flag = 1; //偶数轮，从右向左比较和交换 for (int j = sz - i - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; tmp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = tmp; //有元素交换，所以不是有序，标记变为0 flag = 0; &#125; &#125; if (flag) break; &#125;&#125;void Cocktail_Show(int arr[], int sz)&#123; int i = 0; for (i = 0; i &lt; sz; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; printf(&quot;\\n&quot;);&#125;int main()&#123; int arr[] = &#123; 2,3,4,5,6,7,8,1 &#125;; int sz = sizeof(arr) / sizeof(int); printf(&quot;排序前:&quot;); Cocktail_Show(arr, sz);//打印排序函数 Cocktail_Sort(arr, sz);//排序函数 printf(&quot;排序后:&quot;); Cocktail_Show(arr, sz); return 0;&#125; 代码优化: 思路同冒泡排序,但由于鸡尾酒排序是双向的,需要设定两个边界值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void Cocktail_Sort(int arr[], int sz)&#123; int tmp = 0; //无序数列的左边界，每次比较只需要比到这里为止 int leftBorder = 0; //无序数列的右边界，每次比较只需要比到这里为止 int rightBorder = sz - 1; //记录右侧最后一次交换的位置 int lastRightExchange = 0; //记录左侧最后一次交换的位置 int lastLeftExchange = 0; for (int i = 0; i &lt; sz / 2; i++) &#123; //有序标记，每一轮的初始是true int flag = 1; //奇数轮，从左向右比较和交换 for (int j = leftBorder; j &lt; rightBorder; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; //有元素交换，所以不是有序，标记变为0 flag = 0; lastRightExchange = j; &#125; &#125; rightBorder = lastRightExchange; if (flag) break; //偶数轮之前，重新标记为1 flag = 1; //偶数轮，从右向左比较和交换 for (int j = rightBorder; j &gt; leftBorder; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; tmp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = tmp; //有元素交换，所以不是有序，标记变为0 flag = 0; lastLeftExchange = j; &#125; &#125; leftBorder = lastLeftExchange; if (flag) break; &#125;&#125; 2.2 插入排序和希尔排序算法思想: 每步将一个待排序的元素按照其关键字的值,插入到前面已经排序好的一组数组中适当的位置,使其仍然保持有序。 时间复杂度: 最好情况：数组是有序的或者接近有序的，那么时间复杂度为：O(N) 最坏情况：数组是逆序的，那么时间复杂度为：O(N^2) 空间复杂度：O(1) 算法实现: 1) 直接插入12345678910111213141516171819202122void InsertSort(int* a, int n) &#123; //数组的长度是n，那么最后一个数据是n-1，倒数第二个数据是n-2 for (int i = 0; i &lt; n - 1; ++i) &#123; // [0 end]有序，把end+1的位置的值插入进去，保持它依旧有序 int end = i; //记录有序序列的最后一个元素的下标 int tmp = a[end + 1]; //待插入的元素 while (end &gt;= 0) &#123; if (tmp &lt; a[end]) &#123; a[end + 1] = a[end]; --end; &#125; else &#123; break; &#125; &#125; //代码执行到此位置有两种情况: //1.待插入元素找到应插入位置（break跳出循环到此）。 //2.待插入元素比当前有序序列中的所有元素都小（while循环结束后到此）。 a[end + 1] = tmp; &#125;&#125;","categories":[{"name":"编程技术","slug":"编程技术","permalink":"https://exder145.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://exder145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"EXDER"},{"title":"数据结构笔记 -- 队列","slug":"队列","date":"2024-09-29T16:00:00.000Z","updated":"2024-12-30T12:14:58.475Z","comments":true,"path":"2024/09/30/队列/","link":"","permalink":"https://exder145.github.io/2024/09/30/%E9%98%9F%E5%88%97/","excerpt":"关于队列知识的总结,附源教学网站","text":"关于队列知识的总结,附源教学网站 原文：【精选】队列(Queue)_JFS_Study 的博客-CSDN 博客 一、队列的概念队列是一个先进先出的数据结构。联想一下链表，在单链表中，只能对表尾进行插入，对表头进行结点的删除，这样强限制性的链表，就是所说的队列。也就是说，队列是限定在表的一端进行插入，表的另一端进行删除的数据结构。 如图去买票排队，每一列队伍都有一个队尾和队首，先来的先买票，后来的后买，买好的就从队首出去，新来买票的就需要从队尾继续排队。 通常，称进数据的一端为队尾，出数据的一端为队首，数据元素进队列的过程称为入队，出队列的过程称为出队。 队列是一个线性的数据结构，并且这个数据结构只允许在一端进行插入，另一端进行删除，禁止直接访问除这两端以外的一切数据，且队列是一个先进先出的数据结构。 如上图，队列就像一个两端相通的水管，只允许一端插入，另一端取出，取出的球就不在水管里面了，而先放入管中的球就会先从管中拿出。 队列存储结构的实现有以下两种方式：①顺序队列：在顺序表的基础上实现的队列结构。②链队列：在链表的基础上实现的队列结构。 两者的区别仅是顺序表和链表的区别，即在实际的物理空间中，数据集中存储的队列是顺序队列，分散存储的队列是链队列。 二、队列的结点设计与初始化队列只有链式的设计方法，其本身分为多种队列，如顺序队列和循环队列，还有衍生的优先队列等等，以顺序队列的设计为例。 首先是队列的结点设计，可以设计出两个结构体，一个结构体 Node 表示结点，其中包含有 data 域和 next 指针，如图： 其中 data 表示数据，其可以是简单的类型，也可以是复杂的结构体。next 指针表示，下一个的指针，其指向下一个结点，通过 next 指针将各个结点链接。 然后再添加一个结构体，其包括了两个分别永远指向队列的队尾和队首的指针，看到这里是不是觉得和栈很像？ 主要的操作只对这两个指针进行操作，如图所示： 其结构体设计的代码可以表示为： 12345678910111213//结点定义typedef struct node&#123; int data; struct node *next;&#125;node;//队列定义，队首指针和队尾指针typedef struct queue&#123; node *front;//头指针 node *rear;//尾指针&#125;queue; 对于初始化需要初始化两个类型，一个是初始化结点，一个是初始化队列。代码中的描述，初始化队列有些不同，当初始化队列的时候，需要将头尾两个结点指向的内容统统置为空，表示是一个空队列，两个创建的函数代码可以表示为： 1234567891011121314151617181920212223//初始化结点node *init_node&#123; node *n=(node*)malloc(sizeof(node)); if(n==)&#123;//建立失败，退出 exit(0); &#125; return n;&#125;//初始化队列queue *init_queue &#123; queue *q=(queue*)malloc(sizeof(queue)); if(q==) &#123;//建立失败，退出 exit(0); &#125;//头尾结点均赋值 q-&gt;front=; q-&gt;rear=; return q;&#125; 三、判断队列是否为空这是一个既简单也很要紧的操作，判断队列是否为空直接就是判断队列头指针是否是空值即可。其代码可以表示为： 1234567891011//队列判空int empty(queue *q) &#123; if(q-&gt;front==NULL) &#123; return 1;//1--表示真，说明队列非空 &#125;else&#123; return 0;//0--表示假，说明队列为空 &#125;&#125; 或者直接利用返回值进行更简单的判断也可以，代码如下： 123int empty (queue *q) &#123; return q-&gt;front==;&#125; 四、入队操作入队操作变化图： 进行入队(push)操作的时候，同样的，首先需要判断队列是否为空，如果队列为空的话，需要将头指针和尾指针一同指向第一个结点，代码如下： 123front=n;rear=n;12 如图： 如果队列不为空的时候，这时只需要将尾结点向后移动，通过不断移动 next指针指向新的结点构成队列即可。如图： 其代码可以表示为： 1234567891011121314151617//入队操作void push(queue *q,int data) &#123; node *n =init_node; n-&gt;data=data; n-&gt;next=;//采用尾插入法 //if(q-&gt;rear==)&#123;//使用此方法也可以 if(empty(q)) &#123; q-&gt;front=n; q-&gt;rear=n; &#125;else&#123; q-&gt;rear-&gt;next=n;//n成为当前尾结点的下一结点 q-&gt;rear=n;//让尾指针指向n &#125;&#125;12345678910111213141516 五、出队操作出队操作变化图： 出队(pop)操作，是指在队列不为空的情况下进行的一个判断，当然在此也一定要进行队列判空的操。 如图，如果队列只有一个元素了，也就是说头尾指针均指向了同一个结点，那么直接将头尾两指针置空，并释放这一个结点即可，如图： 当队列含有以上个元素时，需要将队列的头指针指向头指针当前指向的下一个元素，并释放掉当前元素即可，如图： 其代码可以表示为： 1234567891011121314151617//出队操作void pop(queue *q) &#123; node *n=q-&gt;front; if(empty(q))&#123; return ;//此时队列为空，直接返回函数结束 &#125; if(q-&gt;front==q-&gt;rear)&#123; q-&gt;front=;//只有一个元素时直接将两端指向置为空即可 q-&gt;rear=; free(n);//记得归还内存空间 &#125;else&#123; q-&gt;front=q-&gt;front-&gt;next; free(n); &#125;&#125;12345678910111213141516 六、打印队列元素(遍历)打印队列的全部元素可以帮助调试，看到队列中具体的数据，在队列不为空的情况下，通过结点的 **next **指向依次遍历并输出元素既可。其代码可以表示为： 12345678910111213//打印队列元素void print_queue(queue *q)&#123;node *n = init_node;n=q-&gt;front;if(empty(q))&#123; return ;//此时队列为空，直接返回函数结束 &#125;while (n!=)&#123;printf(&quot;%d\\t&quot;,n-&gt;data);n=n-&gt;next;&#125;printf(&quot;\\n&quot;); //记得换行&#125;123456789101112 遍历操作还有很多别的表示方法，比如说进行计算队列中含有多少元素，代码如下： 123456789101112131415int calac(queue *q)&#123;node *n = init_node;n=q-&gt;front;int cnt=0;//计数器设计if(empty(q))&#123;return 0;//此时队列为空，直接返回函数结束&#125;while (n!=) &#123; n=n-&gt;next; cnt++;&#125;return cnt;&#125;1234567891011121314 七、顺序队列的假溢出什么是假溢出？这里需要考虑到顺序队列有什么缺点，对于顺序队列而言，其存在已经足够解决大多时候的设计问题了，但是其依旧存在一些缺陷和不足。 从上面的解析中看到，入队和出队操作均是直接在其后面进行结点的链接和删除，这种操作会造成其使用空间不断向出队的那一边偏移，产生假溢出。 来打一个比方，先看图： 上图所示，有一个顺序队列，这个队列的大小为 5，其已经包含了四个元素 data1 , data2 , data3 , data4。 接着，对这个队列进行出队操作，出队 2 个元素，队列就变成了这个样子，如图： 从图上看到似乎没有什么问题，但是当接着再进行入队操作，比如入队 2 个元素，分别是 data5和** data6**。 此时已经发现问题了，尾指针移动到可以进行队列操作的范围之外去了，有没有发现？ 这种现象称呼作为队列用的存储区还没有满，但队列却发生了溢出，把这种现象称为假溢出。如图： 那么有什么办法解决这个问题呢？这就要涉及到循环队列的性质了！ 八、循环队列的概念可能这个时候会产生一个疑问，学习的队列不是使用链表实现的动态队列么？没有空间的时候会开辟空间，这难道还会产生假溢出么？**的确，当进行动态创建队列的时候，也只不过是向后继续不断的申请内存空间；即使前面出队操作释放掉了前面的空间，但是指针依旧会**向后进行移动，直到达到系统预留给程序的内存上界被强行终止；这对于极为频繁的队列操作和程序而言是致命的，这时候，就需要对我们的队列进行优化，使用更为优秀的结构——循环队列。 循环队列就是将队列存储空间的最后一个位置转而绕到第一个位置，形成逻辑上的环状空间，以此来供队列循环使用，如图： 循环队列就是给定队列的大小范围，在原有队列的基础上，只要队列的后方满了，就从这个队列的前面开始进行插入，以达到重复利用空间的效果；由于循环队列的设计思维更像一个环，因此常使用一个环图来表示，但我们需要注意，实际上循环队列不是一个真正的环，它依旧是单线性的。 九、循环队列的结构设计由于循环对列给定了数据范围的大小，所以不需要使用链式的动态创建方法了。因为如果使用链式存储，会无法确定何时再回到队头进行插入操作，所以采用模拟的方法，如图： 其中，data 表示一个数据域，int 为类型，其可以修改为任意自定义的类型，比如说简单的 char，float 类型等等，也可以是复杂的结构体类型。 maxsize表示循环队列的最大容纳量，其表示队列的全部可操作空间。 rear代表尾指针，入队时移动。 front代表头指针，出队时移动。 其代码可以表示为： 12345678910#define maxsize 10//表示循环队列的最大容量//循环队列的结构设计typedef struct cir_queue&#123;int data[maxsize];int rear;int front;&#125;cir_queue;123456789 十、循环队列的初始化循环队列的初始化核心就在于申请空间，并且将 front 指针和 rear 指针内容赋值为 0，即指向第 0 个元素即可，这里要注意第 0 个元素内容为空，如图： 其代码可以表示为： 1234567891011//初始化cir_queue *init&#123;cir_queue *q = (cir_queue*)malloc(sizeof(cir_queue));if(q==)&#123; exit(0);//申请内存失败，退出程序&#125;q-&gt;front=0;q-&gt;rear=0;return q;&#125;12345678910 十一、循环队列的入队操作入队操作同顺序队列的方法，直接将 rear 向后移动即可。但是要注意判断，如果 rea r 达到了队列的空间上线，将要从头继续开始移动。这里推荐使用余数法，即无论如何求余都是在这片空间内进行操作，防止一次错误执行就直接整体崩溃，而且也相对而言更为简洁，不推荐使用 if 语句，这样显得比较累赘。 注意进行加一移动位置操作的时候，不能直接 **q-&gt;rear++ **这样的操作，这样计算机判断优先级会产生让自己意想不到的后果。此外这里还需要进行一次是否队列已满的判断，当我们 rear 指针的下一个位置就是 front 的位置的时候，即改循环队列已满。如图： 其代码可以表示为： 1234567891011//入队操作pushvoid push(cir_queue *q,int data)&#123;if((q-&gt;rear+1)%maxsize==q-&gt;front)&#123;printf(&quot;溢出，无法入队\\n&quot;);return;&#125;else&#123;q-&gt;rear=(q-&gt;rear+1)%maxsize; q-&gt;data[q-&gt;rear]=data;&#125;&#125;12345678910 十二、循环队列的出队操作如果顺序队列的出队操作，直接将 front 进行后移一位即可。 这里上面很多地方都提过了，有一个需要留意的地方，即队列是否为空，当队列为空的时候是无法进行出队操作的。 其代码可以表示为： 1234567891011//出队操作popvoid pop(cir_queue *q)&#123;if(q-&gt;rear==q-&gt;front)&#123;printf(&quot;队列为空，无法出队\\n&quot;);return;&#125;else&#123;q-&gt;data[q-&gt;front]=0;q-&gt;front=(q-&gt;front+1)%maxsize; &#125;&#125;12345678910 十三、循环队列的遍历操作遍历操作需要借助一个临时变量储存位置 front 的位置信息，利用 i 逐步向后移动，直到 i 到达了 rear 的位置即可宣告遍历的结束。 123456789//遍历队列void print(cir_queue *q)&#123;int i=q-&gt;front;while(i!=q-&gt;rear)&#123; i=(i+1)%maxsize;printf(&quot;%d\\t&quot;,q-&gt;data[i]);&#125;printf(&quot;\\n&quot;);//记得换行&#125;","categories":[{"name":"编程技术","slug":"编程技术","permalink":"https://exder145.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://exder145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"EXDER"},{"title":"MYSQL基本语法","slug":"MYSQL基本语法","date":"2024-07-09T16:00:00.000Z","updated":"2024-12-30T12:32:42.459Z","comments":true,"path":"2024/07/10/MYSQL基本语法/","link":"","permalink":"https://exder145.github.io/2024/07/10/MYSQL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"关于 MYSQL 基本语法总结","text":"关于 MYSQL 基本语法总结 MySQL 基本语法概述在数据库管理中，SQL 语句可以分为几个不同的类别，主要包括 DDL (数据定义语言) 和 DML (数据操纵语言)，还有 DCL (数据控制语言) 和 TCL (事务控制语言)。每个类别都有其特定的用途和对应的命令集。 DDL (数据定义语言)DDL，即数据定义语言，主要用于定义和修改数据库结构。这些命令对数据库的结构进行操作，如创建表、修改表结构、删除表等。 常见的 DDL 命令包括： CREATE：用于创建新的数据库或数据库表 ALTER：用于修改现有数据库对象的结构，如添加、删除或修改表中的列 DROP：用于删除整个数据库或表 TRUNCATE：用于删除表中的所有行，但不删除表本身 DQL(数据查询语言)数据库查询语言。关键字：SELECT … FROM … WHERE。 DML (数据操纵语言)DML，即数据操纵语言，主要用于添加、删除、更新和查询数据库记录。 常见的 DML 命令包括： INSERT：向表中插入新的数据行 UPDATE：更新表中的现有数据 DELETE：从表中删除数据 DCL (数据控制语言)DCL，即数据控制语言，用于定义数据库的安全策略和权限控制。 常见的 DCL 命令包括： GRANT：授权用户访问和操作数据库的权限 REVOKE：撤销已经授予的权限 TCL (事务控制语言)TCL，即事务控制语言，用于管理事务，确保数据的完整性。 常见的 TCL 命令包括： COMMIT：提交当前事务，使自上一个 COMMIT 或 ROLLBACK 以来进行的所有修改成为永久性的 ROLLBACK：回滚当前事务，撤销自上一个 COMMIT 或 ROLLBACK 以来进行的所有修改 SAVEPOINT：在事务中设置一个保存点，可以回滚到该点而不是完全回滚事务 这些命令集使数据库管理员和开发者能够有效地管理和操作数据库系统。使用时需要根据实际需要选择合适的命令类型。 DDL 语句-创建表123CREATE TABLE example_table ( id INT AUTO_INCREMENT, name VARCHAR(100) NOT NULL, age INT DEFAULT 0, PRIMARY KEY (id)); 添加列12ALTER TABLE example_tableADD email VARCHAR(255); 删除列12ALTER TABLE example_tableDROP COLUMN email; 修改列类型12ALTER TABLE example_tableMODIFY COLUMN name VARCHAR(200); DQL&#x2F;DML 语句查询操作查询所有管理员信息12-- 查询所有管理员的详细信息SELECT * FROM admins; 查询特定管理员12-- 根据用户名查询管理员信息SELECT * FROM admins WHERE username = &#x27;liulei07&#x27;; 查询特定列12-- 查找数据库某几列SELECT usersname,age FROM members;# 使用逗号链接多个列，from后跟列表名 多个查询条件使用 and 链接 插入操作添加新管理员12-- 插入一个新的管理员记录INSERT INTO admins (username, password, name, avatar, phone, email)VALUES (&#x27;zhangsan&#x27;, &#x27;Zhang123&#x27;, &#x27;张三&#x27;, &#x27;avatar_zhang.jpg&#x27;, &#x27;13812345678&#x27;, &#x27;zhangsan@example.com&#x27;); 删除操作删除指定管理员12-- 删除用户名为 &#x27;zhangsan&#x27; 的管理员DELETE FROM admins WHERE username = &#x27;zhangsan&#x27;;#注意条件：单独修改某一条数据 注意：开自动递增，id 删除后新建数据，id 不会继续递增而是跳过删除的数据 想要 id 重新开始排序：截断表（清空排序） 修改操作更新管理员信息1234-- 更新管理员 &#x27;liulei07&#x27; 的电子邮箱和电话号码UPDATE adminsSET email = &#x27;newemail@example.com&#x27;, phone = &#x27;13987654321&#x27;# 修改某一列的操作，用逗号连接多个列WHERE username = &#x27;liulei07&#x27;;#条件：单独修改某一条数据 分组与聚合统计统计各个用户名下的记录数123-- 统计每个用户名下的记录数量SELECT username, COUNT(*) AS user_countFROM adminsGROUP BY username; 在 SQL 中，分组操作通常与GROUP BY 子句结合使用，这允许你按照一个或多个列对结果集进行分组。这通常用于与聚合函数（如 COUNT, SUM, AVG, MAX, MIN 等）结合，以对各个分组进行统计计算。 获取最大、最小管理员 ID12-- 获取当前管理员中的最大和最小 IDSELECT MAX(admin_id) AS max_id, MIN(admin_id) AS min_idFROM admins; 关联查询创建收货地址表创建一个新的表 shipping_addresses，该表包含管理员的收货地址详情： 12345678910CREATE TABLE shipping_addresses ( address_id INT AUTO_INCREMENT PRIMARY KEY, admin_id INT NOT NULL, address VARCHAR(255) NOT NULL COMMENT &#x27;收货地址详细信息&#x27;, city VARCHAR(100) NOT NULL COMMENT &#x27;城市&#x27;, state VARCHAR(100) NOT NULL COMMENT &#x27;州/省&#x27;, postal_code VARCHAR(20) NOT NULL COMMENT &#x27;邮政编码&#x27;, country VARCHAR(100) NOT NULL COMMENT &#x27;国家&#x27;, FOREIGN KEY (admin_id) REFERENCES admins(admin_id)) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &#x27;管理员的收货地址&#x27;; 插入关联数据12345-- 插入管理员 liulei07 的收货地址INSERT INTO shipping_addresses (admin_id, address, city, state, postal_code, country)VALUES (1, &#x27;1234 Elm St&#x27;, &#x27;Beijing&#x27;, &#x27;Beijing&#x27;, &#x27;100000&#x27;, &#x27;China&#x27;), (1, &#x27;5678 Oak St&#x27;, &#x27;Shanghai&#x27;, &#x27;Shanghai&#x27;, &#x27;200000&#x27;, &#x27;China&#x27;);-- 插入管理员 chenmei12 的收货地址INSERT INTO shipping_addresses (admin_id, address, city, state, postal_code, country)VALUES (2, &#x27;4321 Pine St&#x27;, &#x27;Chengdu&#x27;, &#x27;Sichuan&#x27;, &#x27;610000&#x27;, &#x27;China&#x27;); 进行关联查询操作123-- 查询每个管理员及其所有收货地址SELECT a.username, a.name, sa.address, sa.city, sa.state, sa.postal_code, sa.countryFROM admins aJOIN shipping_addresses sa ON a.admin_id = sa.admin_id; 这个查询将返回管理员的用户名和姓名以及他们的每个收货地址的详细信息。 查询特定管理员的所有收货地址如果您想要查询特定管理员的所有收货地址，可以修改查询条件，例如查询管理员 liulei07： 1234-- 查询管理员 liulei07 的所有收货地址SELECT a.username, a.name, sa.address, sa.city, sa.state, sa.postal_code, sa.countryFROM admins aJOIN shipping_addresses sa ON a.admin_id = sa.admin_idWHERE a.username = &#x27;liulei07&#x27;; JOIN在 SQL 中，连接（JOIN）是用来合并两个或多个表的行的方法，根据表之间的共同字段来合并。连接类型决定了查询如何选择行进行合并。以下是常见的连接类型及其用途： 1. INNER JOIN（内连接）用途：返回两个表中匹配条件的行。如果一行在一个表中匹配但在另一个表中不匹配，则不会显示这行。 示例： 123SELECT *FROM table1INNER JOIN table2ON table1.common_field = table2.common_field; 2. LEFT JOIN（左连接)用途：返回左表（table1）的所有行和右表（table2）中匹配的行。如果右表没有匹配的行，则结果中这部分将为 NULL。 示例： 123SELECT *FROM table1LEFT JOIN table2ON table1.common_field = table2.common_field; 3. RIGHT JOIN（右连接）用途：返回右表（table2）的所有行和左表（table1）中匹配的行。如果左表没有匹配的行，则结果中这部分将为 NULL。 示例： 123SELECT *FROM table1RIGHT JOIN table2ON table1.common_field = table2.common_field; 4. FULL OUTER JOIN（全外连接）用途：返回两个表中的所有行。当某行在一个表中有匹配而在另一个表中无匹配时，对应的无匹配表的部分将为 NULL。注意，MySQL 不直接支持 FULL OUTER JOIN，但可以通过 UNION 实现。 示例（模拟全外连接）： 123456SELECT *FROM table1LEFT JOIN table2ON table1.common_field = table2.common_fieldUNIONSELECT *FROM table1RIGHT JOIN table2ON table1.common_field = table2.common_field; 5. CROSS JOIN（交叉连接）用途：返回第一个表的每一行与第二个表的每一行的笛卡尔积。如果两个表分别有 5 行和 4 行，那么结果将有 20 行。 示例： 12SELECT *FROM table1CROSS JOIN table2; 6. SELF JOIN（自连接）用途：是一种特殊情况的内连接，表通过自身与自身连接，常用于组织结构、层级数据等场景。 示例： 1234SELECT a.name AS EmployeeName, b.name AS ManagerNameFROM employees aJOIN employees bON a.manager_id = b.employee_id; 在 SQL 中进行 JOIN 操作时，ON 关键字是用来指定 JOIN 的条件的，它定义了两个表如何关联在一起。通过 ON 条件，SQL 引擎能够决定如何精确地匹配来自两个表的行。这个条件通常涉及到两个表中共有的一个或多个字段。","categories":[{"name":"编程技术","slug":"编程技术","permalink":"https://exder145.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://exder145.github.io/tags/MYSQL/"}],"author":"EXDER"},{"title":"学习网站整理","slug":"常用网站整理","date":"2023-11-11T16:00:00.000Z","updated":"2024-12-27T06:21:54.359Z","comments":true,"path":"2023/11/12/常用网站整理/","link":"","permalink":"https://exder145.github.io/2023/11/12/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/","excerpt":"note quote 给一些课程学习所需要的网站整理一下(虽然也不一定全会看但当时觉得有用就保存下来了的一些东西) 以便自己查询 日后会不断补充","text":"note quote 给一些课程学习所需要的网站整理一下(虽然也不一定全会看但当时觉得有用就保存下来了的一些东西) 以便自己查询 日后会不断补充 数字电路一个中科大编写的课程学习网站: Digital Lab 2023 (ustc.edu.cn) 包括 Verilog 语言学习 Logisim 使用教程 vivado 学习和仿真实验 (包括各种警告信息的含义 我觉得这个比较实用) 实验过程给的很详细 verilog 教程详细版: 1.1 Verilog 教程 | 菜鸟教程 (runoob.com) 清华大学 verilog 语言学习: Verilog 语言 - 计算机组成原理（2021 年） (tsinghua.edu.cn) 更详细的 logisim 上手教程: Logisim 的基本使用方法（详细）教你如何使用 Logisim_吾浴西风的博客-CSDN 博客 包括一些进阶组件的用法 助教老师编写的数字逻辑文档: 首页 (dld-ustb.github.io) 好用滴很呐!感谢助教老师们 而你们才是真正的英雄.jpg 数据结构与算法一位大佬的博客: jitwxs.cn 数据结构 第一章 概论 | Jitwxs 数据结构 第二章 线性表 | Jitwxs 数据结构 第三章 栈和队列 | Jitwxs 数据结构 第四章 串 | Jitwxs 数据结构 第五章 数组和广义表 | Jitwxs 数据结构 第六章 树和二叉树 | Jitwxs 数据结构 第七章 图 | Jitwxs 数据结构 第八章 排序 | Jitwxs 数据结构 第九章 查找 | Jitwxs 算法讲解视频: 十大经典排序算法（C 语言描述） 虽然 b 站各种讲解经典算法的视频非常多,但我看大部分视频都是会了思想不会敲代码( 这位老师会带着你边敲代码边讲解 推荐一下 大学物理(大雾)复习用 知识点总结 �� 讲: 大学物理上知识点总结 老师声音很好听(嗯) 知识点复习的很全面 还会讲经典例题 用来复习很不错 例题讲解:【强烈推荐】大学物理知识点回顾与典型题解析 主要是讲题 例题很典型 避免听懂了(大概)但不会做题的现象 详细课程: 大学物理（汇总版） 黎光旭主讲 （普通物理）力学，振动与波，相对论，电磁学 马文蔚物理学第七版 好评率非常高的一位老师 讲课很清晰风趣 如果时间多(不是一晚上速通)的话可以看看 模电课程: 【模电速成课】【拯救期末系列】【网课时代模电零基础复习】一周复习模电 还没开始看(嗯 期中靠这个救了 先放在这里看完了再评 线代线代的代本质: 线性代数的本质 - 01 - 向量究竟是什么 非常好的对矩阵和线代本质的探讨视频 推荐所有学习者在学线代之前观看 这下终于看懂在学什么了(如果没有这个视频 按照学校老师的无图授课模式估计结课了还不知道究竟学了个什么(悲)) 其它c++教程: C++ 教程 | 菜鸟教程 (runoob.com) linux 命令: Linux 命令大全 | 菜鸟教程 (runoob.com) ASCLL 码表: ASCII 码一览表，ASCII 码对照表 (biancheng.net) 正则表达式测试器: regex101: build, test, and debug regex 四六级真题: 六级真题(2012-2023 年 6 月) | 英语真题在线 (burningvocabulary.cn)","categories":[{"name":"学习","slug":"学习","permalink":"https://exder145.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网页","slug":"网页","permalink":"https://exder145.github.io/tags/%E7%BD%91%E9%A1%B5/"}],"author":"EXDER"}],"categories":[{"name":"编程技术","slug":"编程技术","permalink":"https://exder145.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"},{"name":"学习","slug":"学习","permalink":"https://exder145.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://exder145.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Python","slug":"Python","permalink":"https://exder145.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://exder145.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"verilog","slug":"verilog","permalink":"https://exder145.github.io/tags/verilog/"},{"name":"数据结构","slug":"数据结构","permalink":"https://exder145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"MYSQL","slug":"MYSQL","permalink":"https://exder145.github.io/tags/MYSQL/"},{"name":"网页","slug":"网页","permalink":"https://exder145.github.io/tags/%E7%BD%91%E9%A1%B5/"}]}