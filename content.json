{"meta":{"title":"EXDER's Blog","subtitle":"","description":"","author":"EXDER","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2023-10-24T13:18:09.367Z","updated":"2023-10-24T13:18:09.367Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-12-27T05:30:19.163Z","updated":"2024-12-27T05:30:19.163Z","comments":true,"path":"css/custom.css","permalink":"http://example.com/css/custom.css","excerpt":"","text":"/* 加载动画容器 */ #loading-container { position: fixed; top: 0; left: 0; width: 100%; height: 100vh; background: var(--color-card); z-index: 999999; display: flex; justify-content: center; align-items: center; opacity: 1; visibility: visible; transition: all 0.5s; } #loading-container.hide { opacity: 0; visibility: hidden; } /* 加载动画 */ .loader { display: flex; position: relative; justify-content: center; align-items: center; gap: 1rem; height: 55px; width: 200px; } .container { position: relative; width: 24px; height: 24px; } /* 添加具体的动画元素样式 */ .love, .death, .robots { position: absolute; width: 20px; height: 20px; background: var(--color-text); border-radius: 50%; animation: bounce 1s infinite; } /* 为每个元素设置不同的动画延迟 */ .love { animation-delay: 0.1s; } .death { animation-delay: 0.2s; } .robots { animation-delay: 0.3s; } @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }"},{"title":"","date":"2023-10-26T09:40:14.231Z","updated":"2023-10-26T09:40:14.231Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"In case I don’t see you, good morning,good afternoon and good night. ✨欢迎来到EXDER的博客。✨ ​ 🪄至此本博客的搭建就差不多完成了。虽然界面还没有让我很满意，但完善的工作就交给未来的自己吧（躺） ​ 🔮这个博客建立的初心（应该）主要是用于记录本人的学习历程，当然也会参杂各种学习心得（吐槽）和一些乱七八糟的不太冷知识。 ​ 💤以下是一些废话 ​ 简单介绍一下自己的话，本人的荣誉称号有：老师口中的极个别人，部门不必可少的划水的鱼，现充口中的死宅二刺螈，二次元眼中的臭鲜葱，没有酒精上瘾的跛脚调酒师，时常电子养胃的游戏低手，失败的时间管理大师，拥有美术生梦想的悲惨程序员，fe不算太低的entp，在自律挑战中打败了全球0%的人，有人生来就在罗马，有人出生变成马喽。 ​ 好像扯得有点远了。其实刚建立这个博客时还是有很多犹豫和自我质疑的，一部分原因是不知道三分钟热情的自己能坚持到哪一步,更主要的原因是本人目前基础非常差劲,摆烂的前半生造就了我的今天（悲） ​ （虽然如果再来一次我应该还是会选择摆烂这种话就先不要说了） ​ 所以看过很多大佬的博客后时常会质疑自己建立博客的目的。 如果只是做cs学习笔记的话，自己悄悄记下就好了，有什么必要发布出来呢？比我优秀的大有人在，这份博客又是想让谁看到呢？但是后来偶然翻到自己第一次敲出“HelloWorld”的截图，那份最单纯的欣喜和好奇，自信满满认为前路畅通无阻的幼稚的喜悦像回旋镖击中了已经摆烂一年的我。想要脱离落后-焦虑-摆烂的死循环，最好的办法不过是重头再来。所以本博客建立的主要目的还是记录和督促本人的日常学习，也欢迎大家一起捶打我。(笑 ​ 当然，如果未来有一天，本博客的内容能够给其他学习者带来一些启发，那将是我的莫大荣幸。 ⭐最后引用我很喜欢的JOJO7中的一句台词结束吧： ​ 初めてのキスはJOJOじやなぃ、konodioda！（不是这句 ​ 我现在还只是『负数』！我只是想让自己从『负数』变为『零』而已 ！ ​ —-2023.10.26"},{"title":"","date":"2024-12-27T05:30:19.175Z","updated":"2024-12-27T05:30:19.175Z","comments":true,"path":"js/custom.js","permalink":"http://example.com/js/custom.js","excerpt":"","text":"// 在页面加载前就执行 (function() { document.addEventListener('DOMContentLoaded', function() { const loadingContainer = document.getElementById('loading-container'); if (!loadingContainer) return; // 确保动画至少显示1秒 setTimeout(function() { loadingContainer.classList.add('hide'); setTimeout(function() { loadingContainer.style.display = 'none'; }, 500); }, 1000); }); // 如果页面加载太快也要显示动画 window.addEventListener('load', function() { const loadingContainer = document.getElementById('loading-container'); if (!loadingContainer || loadingContainer.classList.contains('hide')) return; loadingContainer.classList.add('hide'); setTimeout(function() { loadingContainer.style.display = 'none'; }, 500); }); })();"},{"title":"所有标签","date":"2023-10-24T13:18:22.737Z","updated":"2023-10-24T13:18:22.737Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-10-24T13:18:44.838Z","updated":"2023-10-24T13:18:44.838Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"}],"posts":[{"title":"verilog笔记","slug":"verilog笔记","date":"2024-12-26T16:00:00.000Z","updated":"2024-12-27T15:03:00.050Z","comments":true,"path":"2024/12/27/verilog笔记/","link":"","permalink":"http://example.com/2024/12/27/verilog%E7%AC%94%E8%AE%B0/","excerpt":"之前写的 verilog 笔记，记得很混乱，但还是传一下吧","text":"之前写的 verilog 笔记，记得很混乱，但还是传一下吧 数据类型基本模块: 123456789101112module 模块名 ( // 端口定义之间用英文逗号 , 分隔开 输入端口定义, // 输入端口只能是 wire 类型 输出端口定义 // 输出端口可以根据需要定义为 wire 或 reg 类型); // 不要忘记这里的分号 内部信号定义语句 // 内部信号可以根据需要定义为 wire 或 reg 类型 //wire型可省略 模块实例化语句 // 将其他模块接入电路 assign 数据流赋值语句 always 过程赋值语句endmodule 线网（wire）wire 类型表示硬件单元之间的物理连线，由其连接的器件输出端连续驱动。如果没有驱动元件连接到 wire 型变量，缺省值一般为 “Z”。举例如下： 实例 123wire interrupt ;wire flag1, flag2 ;wire gnd = 1&#x27;b0 ; 线网型还有其他数据类型，包括 wand，wor，wri，triand，trior，trireg 等。这些数据类型用的频率不是很高，这里不做介绍。 寄存器（reg）寄存器（reg）用来表示存储单元，它会保持数据原有的值，直到被改写。声明举例如下： 实例 12reg clk_temp;reg flag1, flag2 ; 例如在 always 块中，寄存器可能被综合成边沿触发器，在组合逻辑中可能被综合成 wire 型变量。寄存器不需要驱动源，也不一定需要时钟信号。在仿真时，寄存器的值可在任意时刻通过赋值操作进行改写。例如： 实例 123456reg rstn ;initial begin rstn = 1&#x27;b0 ; #100 ; rstn = 1&#x27;b1 ;end wire 和 reg 的区别1.wire 和 reg 的本质wire 的本质是一条没有逻辑的连线，也就是说输入时什么输出也就是什么。wire 型数据常用来表示以 assign 关键字指定的组合逻辑信号，模块的输入输出端口类型都默认为 wire 型，wire 相当于物理连线，默认初始值是 z（高组态）。如果你把 wire 定义的变量用在有逻辑性的语句中就会出现综合错误：例如：在 always 语句中使用 wire 型定义的变量赋值，综合器就会报错。 reg 型表示的寄存器类型，用于 always 模块内被赋值的信号，必须定义为 reg 型，代表触发器，常用于时序逻辑电路，reg 相当于存储单元，默认初始值是 x（未知状态）。reg 型相对复杂些，其综合后的输出主要还看具体使用的场景：当在组合电路中使用 reg，合成后的仍然是 net 网络；当在时序电路中使用 reg 合成后的才是 register。 2.wire 和 reg 在硬件描述语言中的释义关于 wire 和 reg 在硬件描述语言中的释义一般需要分为以下两个部分来分析：从电路综合角度来说（1）wire 型变量综合出来是一根导线（2）reg 型在 always 语句模块中又分为两种情况(a) always 后的敏感表中是（a or b or c）形式的，也就是不带时钟边沿的，综合出来还是组合逻辑(b) always 后的敏感表中是（posedge clk）形式的，也就是带边沿的，综合出来一般是时序逻辑，会包含触发器（Flip－Flop） 在设计中，输入信号一般来说你是不知道上一级是寄存器输出还是组合逻辑输出，那么对于本级来说就是一根导线，也就是 wire 型。而输出信号则由你自己来决定是组合逻辑输出还是寄存器输出，wire 型、reg 型都可以。但一般的，整个设计的外部输出（即最顶层模块的输出），要求是寄存器输出，较稳定、扇出能力也较好。 从仿真分析角度来说wire 对应于连续赋值，如 assignreg 对应于过程赋值，如 always，initial 3.使用 wire 的情况（1）assign 语句中变量需要定义成 wire 型例如： 1234reg a,b;wire result;…assign result =a&amp;&amp;b; （2）元件例化时候的输出必须用 wire例如： 12345678wire dout;ram u_ram(….out(dout)…); （3）input、output 和 inout 的预设值都是 wire input、inout 类型的端口不能声明为 reg 数据类型，因为 reg 类型常用于保存数值，而输入端口只反映与其相连的外部信号的变化，不应保存这些信号的值。output 类型的端口则可以声明为 wire 或 reg 数据类型。 wire 型为默认数据类型，因此当端口为 wire 型时，不用再次声明端口类型为 wire；但是当端口为 reg 型时，对应的 reg 声明不可省略。 整数（integer）整数类型用关键字 integer 来声明。声明时不用指明位宽，位宽和编译器有关，一般为 32 bit。reg 型变量为无符号数，而 integer 型变量为有符号数。 综合后实际电路里并没有 k这个信号 k只是辅助生成相应的硬件电路。 状态机**FSM **FSM 的概念 注意到电路中存在一个名为状态寄存器的特殊结构，该结构存储了电路当前的状态信息。设寄存器位宽为 n，则该电路的状态数量不会超过 2 的 n 次方，即其状态数量是有限的，因此这种电路结构称为有限状态机（FSM）。 顾名思义，有限状态机就是由一系列数量有限的状态组成的循环机制。它是由寄存器和组合逻辑构成的硬件时序电路。状态机通过控制各个状态的跳转来控制流程，使得整个代码看上去更加清晰易懂，在控制复杂流程的时候，状态机有着明显的设计优势。 设计 FSM（1）画出状态转移图 把实际系统进行逻辑抽象，即实际问题转化为设计要求。首先确定电路输入输出引脚；然后根据实际需要列出所有的状态情况，并对状态顺序进行编号；最后根据状态转移条件画出状态转移图。 （2）确定状态编码和编码方式 编码方式的选择对所设计的电路复杂与否起着重要作用，要根据状态数目确定状态编码和编码方式。 （3）给出状态方程和输出方程 列写状态转移表，选定触发器类型，通过卡诺图化简给出状态方程和输出方程。（此步在 FPGA 编程中可省略） （4）编写 Verilog 代码 按照步骤（1）~（2）编写具有可综合的 Verilog 代码。 状态机分类：moore 和 mealy Moore：输出信号只与现态有关，输入信号不会直接影响到输出信号，而是与当前状态（简称现态）信号一起生成下一状态（简称次态）信号，在时钟的上升沿之后次态转换为现态，才能影响到输出 Mealy：输出信号由现态与输入信号共同生成，输入信号可立刻对输出信号产生影响 两种结构的有限状态机各有优缺点：Moore 型时序更好，但响应要慢一拍，Mealy 型响应最快，但时序上要差一些。一般来说，如果对电路相应速度要求不是非常苛刻的话，推荐使用 Moore 型有限状态机。 FSM 代码实现结构通过分析有限状态机的结构图，我们可以发现其包含三个部分： 第一部分为组合逻辑，通过现态和输入信号生成次态信号。 第二部分为时序逻辑，包含一个带有复位功能的寄存器单元，复位时现态信号变为初始值，否则在每个时钟的上升沿将次态信号赋值给现态信号。 第三部分为组合逻辑，该部分通过现态信号生成各输出信号。 其对应的代码结构为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071module FSM ( input clk, input rst, // ...... // 其他输入输出信号);// 状态空间位数 nparameter WIDTH = 3;// 状态变量reg [WIDTH-1: 0] current_state, next_state;// 为了便于标识，我们用局部参数定义状态的别名代替状态编码localparam STATE_NAME_1 = 3&#x27;d0;localparam STATE_NAME_2 = 3&#x27;d1;// ......// ==========================================================// Part 1: 使用同步时序进行状态更新，即更新 current_state 的内容。// ==========================================================always @(posedge clk) begin // 首先检测复位信号 if (rst) current_state &lt;= RESET_STATE; // 随后再进行内容更新 else current_state &lt;= next_state;end// ==========================================================// Part 2: 使用组合逻辑判断状态跳转逻辑，即根据 current_state 与// 其他信号确定 next_state。// ==========================================================// 一般使用 case + if 语句描述跳转逻辑always @(*) begin // 先对 next_state 进行默认赋值，防止出现遗漏 next_state = current_state; case (current_state) STATE_NAME_1: begin // ...... end STATE_NAME_2: begin // ...... end default: begin // ...... end endcaseend// ==========================================================// Part 3: 使用组合逻辑描述状态机的输出。这里是 mealy 型状态机// 与 moore 型状态机区别的地方。// ==========================================================// 可以直接使用 assign 进行简单逻辑的赋值assign out1 = ......;// 也可以用 case + if 语句进行复杂逻辑的描述always @(*) begin case (current_state) STATE_NAME_1: begin // ...... end STATE_NAME_2: begin // ...... end default: begin // ...... end endcaseendendmodule 一个实例 数字锁 某助教有一个神奇的锁。锁盘上只有两个按键，我们不妨记为 0 和 1。只有按键按照 0100 的顺序按下时才能解锁成功。例如，连续按下 01010 时并不会解锁，但再按下 0 后便会解锁（因为最近的四次输入为 0100）。我们想用一个数字电路判断给定的按键顺序能否解锁。 模块的输入包含一个时钟信号 clk 以及按下的按键编号 in。由于只有两个按键，所以我们可以根据 in 的高低电平区分按下的按键（例如高电平代表按下 1）。在 clk 的上升沿模块接收一个按键信息，同时输出一个 unlock 信号，当 unlock 信号为高电平时表明最近四次输入的序列可以解锁。 首先来考虑如何确定状态。自然，我们可以根据当前最近的四个输入标识状态，则对应的状态共有 24&#x3D;16 种。但包含十六个状态的有限状态机无论设计上还是实现上都较为复杂，尽管我们可以通过状态化简消去一部分，但这个过程依然是十分繁琐的。 让我们再次分析这个问题。对于一个给定的输入序列，想要判断其能否开锁，我们只需要关注其最近的输入能否组成 0100 序列。先前我们固定观察最近的四次输入，但实际上有些情况近期是一定不能解锁的，例如序列 1110 至少要再经过三次输入才有可能解锁。 基于这一事实，我们可以只关注输入序列是否包含 0100 及其子序列，即考察最近的输入内容为 0、01、010、0010 四种情况。我们称之为后缀识别。 在最开始没有任何输入时，我们可以引入一个初始状态（不妨记作 - ），用于代表不属于上述四种的情况。接下来当输入一个 0 时，我们就识别到了后缀 0，即可进入下一状态；若输入一个 1，则不属于任何一种后缀，因此依然在初始状态。以此类推，我们就得到了下图所示的状态机。 构建流程 于是，我们就可以确定下来，这个问题的状态机一共有五个基本状态。我们约定如下的对应关系： S0：对应 - S1：对应 0 S2：对应 01 S3：对应 010 S4：对应 0100 初始状态为 S0，仅在 S4 状态时输出解锁信号。由于输出仅和当前状态有关，因此我们可以选择 Moore 型状态机进行设计。五个状态可以使用 3bits 位宽的编码进行处理。 首先定义状态变量以及状态名称： 123456reg [2:0] current_state, next_state;localparam S0 = 3&#x27;d0;localparam S1 = 3&#x27;d1;localparam S2 = 3&#x27;d2;localparam S3 = 3&#x27;d3;localparam S4 = 3&#x27;d4; 接下来编写第一段：状态更新。假定 reset 信号的效果是清除之前所有的输入，恢复初始状态。则按下 reset 后状态机应当跳转到 S0。 123456always @(posedge clk) begin if (reset) current_state &lt;= S0; else current_state &lt;= next_state;end 接下来编写第二段：状态转移。根据状态转换图，我们可以编写如下的代码： 123456789101112131415161718192021222324252627282930313233343536373839always @(*) begin next_state = current_state; case (current_state) S0: begin // - if (in) next_state = S0; // - else next_state = S1; // 0 end S1: begin // 0 if (in) next_state = S2; // 01 else next_state = S1; // 0 end S2: begin // 01 if (in) next_state = S0; // - else next_state = S3; // 010 end S3: begin // 010 if (in) next_state = S2; // 01 else next_state = S4; // 0100 end S4: begin // 0100 if (in) next_state = S2; // 01 else next_state = S1; // 0 end endcaseend 输出： 1assign unlock = (current_state == S4) ? 1&#x27;B1 : 1&#x27;B0; 课堂笔记 另外的表述方式： 另一个例子： 选择器 优先级编码器 或者: 加法器 全加器结构 其他内容:组合逻辑电路及其 Verilog 实现 latch 的产生和避免锁存器,触发器,寄存器锁存器（Latch），是电平触发的存储单元，数据存储的动作取决于输入时钟（或者使能）信号的电平值。仅当锁存器处于使能状态时，输出才会随着数据输入发生变化。 当电平信号无效时，输出信号随输入信号变化，就像通过了缓冲器；当电平有效时，输出信号被锁存。激励信号的任何变化，都将直接引起锁存器输出状态的改变，很有可能会因为瞬态特性不稳定而产生振荡现象。 锁存器示意图如下： 触发器（flip-flop），是边沿敏感的存储单元，数据存储的动作（状态转换）由某一信号的上升沿或者下降沿进行同步的（限制存储单元状态转换在一个很短的时间内）。 触发器示意图如下： 寄存器（register），在 Verilog 中用来暂时存放参与运算的数据和运算结果的变量。一个变量声明为寄存器时，它既可以被综合成触发器，也可能被综合成 Latch，甚至是 wire 型变量。但是大多数情况下我们希望它被综合成触发器，但是有时候由于代码书写问题，它会被综合成不期望的 Latch 结构。 Latch 的主要危害有： 1）输入状态可能多次变化，容易产生毛刺，增加了下一级电路的不确定性； 2）在大部分 FPGA 的资源中，可能需要比触发器更多的资源去实现 Latch 结构； 3）锁存器的出现使得静态时序分析变得更加复杂。 产生原因 if 结构不完整 case 结构不完整 敏感信号列表不完整 原信号赋值或判断 连续赋值:always 和 initial过程赋值语句用于对 reg 型变量进行赋值，由 2 种关键字引导，分别是 initial 与 always。这两种语句不可嵌套使用，彼此间 并行 执行（执行的顺序与其在模块中的前后顺序没有关系）。如果 initial 或 always 语句内包含多个语句，则需要搭配关键字 begin 和 end 组成一个块语句。 区别每个 initial 语句或 always 语句都会产生一个独立的控制流，执行时间都是从 0 时刻开始。二者的区别在于 : initial 执行一次语句 always 循环执行 格式敏感变量就是触发 always 块内部语句的条件。加入敏感变量后，always 语句仅在列表中的变量发生变化时才执行内部的过程语句。 1234567// 每当 a 或 b 的值发生变化时就执行内部的语句always @(a or b) begin //是的括号里面这东西叫敏感列表 //所有赋值号右边出现的信号都要放到敏感表里 写全避免latch产生 //每个数据连接用 or [过程语句]end 有的时候，敏感列表过多，一个一个加入太麻烦，且容易遗漏。为了解决这个问题，Verilog 2001 标准允许使用符号 * 在敏感列表中表示缺省，编译器会根据 always 块内部的内容自动识别敏感变量。 例如，先前的例子可以写为： 12345reg Cout;wire A, B;always @(*) begin Cout = A &amp; B;end 除了直接使用信号作为敏感变量，Verilog 还支持通过使用 posedge 和 negedge 关键字将电平变化作为敏感变量。其中 posedge 对应上升沿，negedge 对应下降沿。例如：下面的代码仅在 clk 从低电平（0）变为高电平（1）时触发。 123456reg Cout;wire A, B, clk;always @(posedge clk) begin Cout &lt;= A &amp; B;end assign语句中被赋值的信号定义成wire 过程块中被赋值的信号定义成reg (寄存器 可以改变值的变量形式) assign 连续赋值 与物理线不同但十分相似,Verilog 中的线(和其他信号)是有方向的.这意味着信息只在一个方向上流动,从(通常是一个)源流向汇点(源通常也被称为驱动端,将值驱动到 wire 上).在 verilog 的”连续赋值”(assign)中,右侧的信号值被驱动到左侧的”线”上.请注意:赋值是”连续的”,如果右侧的值发生更改,左侧的值将持续随之改变.(这里与其他语言有很大区别).连续赋值不是一次性事件,其赋值功能是永久持续的. 想要真正理解为啥会这样,你首先要明白,你并不是在编写程序,你其实是在用代码”画”电路! 因此输入端的电平高低的变化必然会影响到 wire 的另一端,你可以想像真的有一根电线连接两个变量. 模块(module)上的端口(port)也有方向(通常是输入 – input 或输出 – output).输入端口由来自模块外部的信号驱动,而输出端口驱动外部的信号.从模块内部查看时,输入端口是驱动源,而输出端口是接收器. 下图说明了电路的每个部分如何对应 Verilog 代码的每个部分.模块和端口声明可以创建黑色盒子的电路.你的任务是通过添加一个 assign 语句来创建一条线(绿色).盒子外的部件不需你考虑,但你应该知道,将测试激励连接到 top_module 上的端口可以来测试黑色盒子电路. 下图说明了电路的每个部分如何对应 Verilog 代码的每个部分.模块外部有三个输入端口和四个输出端口. 当您有多个 assign 语句时,它们在代码中的出现顺序并不重要.与编程语言不同,assign 语句(“连续赋值”)描述事物之间的连接,而不是将值从一个事物复制到另一个事物的操作. 可能现在应该澄清的一个潜在的困惑来源是:这里的绿色箭头表示电线之间的连接,但不是 wire 本身.模块本身已经声明了 7 条线(名为 A、B、C、W、X、Y 和 Z).这是因为 input 与 output 被声明为了 wire 类型.因此,assign 语句不会创建 wire,而是描述了在已存在的 7 条线之间创建的连接. Verilog 的三种描述层次 结构化描述方式：调用其他已经定义过的低层次模块对整个电路的功能进行描述，或者直接调用 Verilog 内部预先定义的基本门级元件描述电路的结构进行描述。 数据流描述方式：使用连续赋值语句 assign 对电路的逻辑功能进行描述。该方式特别适合于对组合逻辑电路建模。 行为级描述方式：使用过程块语句结构 always 和比较抽象的高级程序语句对电路的逻辑功能进行描述。 结构化描述方式考虑下图所示的电路： 如果从结构化层面来描述电路，我们需要刻画与门、或门和非门，并将其正确连接。 Verilog 常用的内置逻辑门包括： and（与门） nand（与非门） or（或门） nor（或非门） xor（异或门） xnor（同或门） 我们可以通过类似模块例化的方式使用这些逻辑门，进而实现一些简单的逻辑功能。 下面是使用门级单元结构化描述该电路的 Verilog 代码。 123456789101112131415module MUX2( input a, b, input sel, output out);wire and1, and2, sel_not;and (and1, a, sel_not);and (and2, b, sel);not (sel_not, sel);or (out, and1, and2);endmodule 数据流描述方式数据流描述方式需要我们得到逻辑表达式。可以将门电路转换为对应的逻辑表达式： 1234and (and1, a, sel_not); // and1 = a &amp; sel_notand (and2, b, sel); // and2 = b &amp; selnot (sel_not, sel); // sel_not = ~selor (out, and1, and2); // out = and1 | and2 化简得到输出 out 关于输入 a、b 和 sel 的逻辑表达式： 1out = (a &amp; ~sel) | (b &amp; sel); 由此可以得到基于 assign 语句的数据流描述。 123456789module MUX2( input a, b, input sel, output out);assign out = (a &amp; ~sel) | (b &amp; sel);endmodule 行为级描述方式很多时候，我们难以得到模块的电路结构，或者得到的结构十分繁琐，这时我们就可以使用行为级描述，以类似于高级语言的抽象层次进行硬件结构开发。这一层面的描述过程更看重功能需求与算法实现，也是对于我们最为友好的描述方式。 下面是该电路的行为级描述代码。 12345678910111213module MUX2( input a, b, input sel, output reg out);always @(*) begin if (!sel) out = a; else out = b;endendmodule 数据表示方式","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"http://example.com/tags/verilog/"}],"author":"EXDER"},{"title":"hexo博客更新后一键上传脚本","slug":"hexo博客一键更新脚本","date":"2024-12-25T16:00:00.000Z","updated":"2024-12-26T05:23:28.438Z","comments":true,"path":"2024/12/26/hexo博客一键更新脚本/","link":"","permalink":"http://example.com/2024/12/26/hexo%E5%8D%9A%E5%AE%A2%E4%B8%80%E9%94%AE%E6%9B%B4%E6%96%B0%E8%84%9A%E6%9C%AC/","excerpt":"如题，因为每次更新博客逐步上传太麻烦而写的一个简单的自动化脚本","text":"如题，因为每次更新博客逐步上传太麻烦而写的一个简单的自动化脚本 介绍本脚本是一个用于自动化 Hexo 博客更新和部署的批处理文件，确保博客内容的清理、生成和上传到远程仓库。 功能概述 切换目录：脚本首先切换到 Hexo 项目的根目录，以确保后续命令在正确的环境中执行。 清理旧文件：使用 hexo clean 命令清理旧的生成文件，确保没有过时的内容残留。 生成静态文件：通过 hexo generate 命令生成最新的静态文件，准备好要部署的内容。 部署到远程仓库：使用 hexo deploy 命令将生成的静态文件上传到配置的远程仓库。 错误处理：每个步骤都包含错误检查，如果某个命令失败，脚本会输出错误信息并停止执行。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@echo offchcp 65001setlocal enabledelayedexpansioncolor 0A:: 切换到博客目录echo 切换到博客目录...cd /d C:\\hexo\\blog (修改为自己的博客目录)if errorlevel 1 ( color 0C echo 切换目录失败！ pause exit /b 1):: 打印信息echo 开始更新博客...:: 清理旧文件echo 清理旧文件...call hexo cleanif errorlevel 1 ( color 0C echo Hexo clean 失败 pause exit /b 1):: 生成静态文件echo 生成静态文件...call hexo generateif errorlevel 1 ( color 0C echo Hexo generate 失败 pause exit /b 1):: 部署到远程仓库echo 部署到远程仓库...call hexo deployif errorlevel 1 ( color 0C echo Hexo deploy 失败 pause exit /b 1):: 打印完成信息color 0Aecho 博客更新完成！pause","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}],"author":"EXDER"},{"title":"sql server无法连接的问题","slug":"sql server常见问题","date":"2024-12-24T16:00:00.000Z","updated":"2024-12-27T07:01:58.071Z","comments":true,"path":"2024/12/25/sql server常见问题/","link":"","permalink":"http://example.com/2024/12/25/sql%20server%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"记录一下 sql server 连接不上的问题","text":"记录一下 sql server 连接不上的问题 SQL Server 数据库连接问题连接测试用代码:12345678910111213141516171819202122232425import pymssql# 数据库连接信息 (修改为自己的)username = &#x27;sa&#x27;password = &#x27;hp6252&#x27;database = &#x27;news&#x27;server = &#x27;localhost&#x27;port = &#x27;1433&#x27;try: # 尝试连接数据库 connect = pymssql.connect(server=server, port=port, user=username, password=password, database=database) cursor = connect.cursor() print(&quot;连接成功！&quot;) # 执行简单查询 cursor.execute(&quot;SELECT 1&quot;) result = cursor.fetchone() print(&quot;查询结果:&quot;, result) # 关闭游标和连接 cursor.close() connect.close()except pymssql.Error as e: print(&quot;连接失败:&quot;, e) 能解决大部分问题的方案解决方案: 重启数据库服务 直接在任务管理器图示位置进行服务重启,或: 进入 CMD，输入 services.msc ，进入到服务页面,找到 SQL Server(SQLEXPRESS)右键重启。 可以顺手把启动方式该成自动。 后重新启动 ssms。进行验证 如果还是不能解决的方案若仍然无效，可通过以下步骤进行排查： 1. 确认 SQL Server 服务是否运行 打开“服务”管理工具 找到 SQL Server 服务（通常是以 SQL Server (MSSQLSERVER) 命名） 确认其状态为“正在运行”。 代码示例在命令提示符中可以使用以下命令来查看服务状态： 12sc query &quot;MSSQLSERVER&quot;1. 2. 检查网络连接如果 SQL Server 服务正常运行，下一步需要检查网络连接是否正常。可以通过 ping 命令测试连接： 12ping &lt;数据库服务器IP&gt;1. 代码示例假设数据库服务器的 IP 地址为 192.168.1.100，可以使用以下命令： 12ping 192.168.1.1001. 如果无法 ping 通，需检查网络设置或是否有防火墙阻止连接。 3. 验证 SQL Server 实例名和端口在连接数据库时，确保使用了正确的实例名和端口。如果使用的是默认实例，通常可以直接使用服务器的 IP 地址或主机名。如果使用的是命名实例，则需要在连接字符串中指定实例名。 例子默认实例连接字符串: 12Server=192.168.1.100;Database=SampleDB;User Id=myUsername;Password=myPassword;1. 命名实例连接字符串: 12Server=192.168.1.100\\SQLExpress;Database=SampleDB;User Id=myUsername;Password=myPassword;1. 4. 检查 SQL Server 配置管理器确保 SQL Server 正在接受远程连接。可以通过以下步骤在 SQL Server 配置管理器中进行检查： 打开 SQL Server 配置管理器 点击 “SQL Server 网络配置”，然后选择 “协议”。 确保 “TCP&#x2F;IP” 协议已启用。 5. 防火墙设置如果服务和网络连接正常，我们还需要检查防火墙设置。确保 SQL Server 所使用的端口（默认是 1433 对于 TCP&#x2F;IP）已被允许通过防火墙。 代码示例（Windows 防火墙配置）在命令提示符中使用以下命令允许 1433 端口： 12netsh advfirewall firewall add rule name=&quot;SQL Server Port 1433&quot; dir=in action=allow protocol=TCP localport=14331. 6. 使用 SQLCMD 测试连接可以使用 SQL Server 提供的 SQLCMD 工具来测试连接，以确保连接字符串的正确性。 代码示例12sqlcmd -S 192.168.1.100 -U myUsername -P myPassword1. 如果连接成功，则会提示 入 SQL 命令。 7. 错误日志如果以上步骤仍未解决问题，可以查阅 SQL Server 错误日志。错误日志通常可以在 SQL Server Management Studio 的“管理”部分找到。 代码示例查看错误日志的 SQL 语句： 登录后复制 1EXEC xp_readerrorlog;","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"EXDER"},{"title":"爬虫环境配置总结","slug":"Crawl4AI爬虫","date":"2024-12-23T16:00:00.000Z","updated":"2024-12-26T05:23:26.728Z","comments":true,"path":"2024/12/24/Crawl4AI爬虫/","link":"","permalink":"http://example.com/2024/12/24/Crawl4AI%E7%88%AC%E8%99%AB/","excerpt":"记录一下配置和学习 Crawl4AI 爬虫工具中遇到的问题，以便日后查阅。","text":"记录一下配置和学习 Crawl4AI 爬虫工具中遇到的问题，以便日后查阅。 官网：Home - Crawl4AI Documentation 中文教程网站：和 GPT 一起学习全栈技术。 初始环境检查首先需要检查以下几个基础组件: Chrome 浏览器是否正确安装 Python 环境是否配置完成 相关依赖包的版本是否符合要求 这些都是后续操作的基础,如果这一步出现问题会影响到整个配置过程 需要安装以下的包: pip install crawl4ai 其他： Playwright: playwright install chrome 解析器: lxml, html5lib, beautifulsoup4 存在问题在使用官方推荐的测试代码（如下）时，出现 lxml 解析器无法正常使用，chromo 无法使用等问题。 1234567891011121314import asynciofrom crawl4ai import AsyncWebCrawlerasync def main(): # Create an instance of AsyncWebCrawler async with AsyncWebCrawler(verbose=True) as crawler: # Run the crawler on a URL result = await crawler.arun(url=&quot;https://www.nbcnews.com/business&quot;) # Print the extracted content print(result.markdown)# Run the async main functionasyncio.run(main()) lxml 解析器问题处理步骤： 首先卸载现有的 lxml： 1pip uninstall lxml 然后重新安装所需的所有解析器： 123pip install lxmlpip install html5libpip install beautifulsoup4 随后测试，显示所有基本依赖都已正确安装。 Chrome 无法使用（半解决）根据报错内容，发现错误信息显示：找不到 Chrome 浏览器，更换为本地完整路径也无效 解决方法：重新安装 Playwright 的 Chrome 浏览器 注：本地 chrome 浏览器与 Playwright 的 Chrome 浏览器并非同一个！ 12# 安装 Playwright 的 Chromeplaywright install chrome 验证 Playwright 的 Chrome 是否安装成功： 12playwright --versionplaywright show-browsers 原因： Playwright 的工作方式 Playwright 使用自己管理的浏览器版本，而不是系统安装的 Chrome 这样做是为了确保跨平台兼容性和版本控制 即使已经安装了 Chrome，Playwright 也需要安装自己的版本 为什么要这样做？ 版本控制：确保代码在所有环境中都能正常运行 隔离性：避免与系统浏览器的配置冲突 自动化控制：更好地支持自动化测试和爬虫功能 但悲伤的是，经测试其他爬虫方法都可以正常使用 Chrome，唯独在使用 Crawl4AI 时 Chrome 死活连 �� 不上。在挣扎了二十分钟后终于屈服了，换为了火狐浏览器完美解决 官网给出的测试代码： （默认为 chrome） 1234567891011121314import asynciofrom crawl4ai import AsyncWebCrawlerasync def main(): # Create an instance of AsyncWebCrawler async with AsyncWebCrawler(verbose=True) as crawler: # Run the crawler on a URL result = await crawler.arun(url=&quot;https://www.nbcnews.com/business&quot;) # Print the extracted content print(result.markdown)# Run the async main functionasyncio.run(main()) 运行后报错： 12345678910111213141516171819202122232425262728293031323334353637383940414243Traceback (most recent call last): File &quot;c:\\Users\\EXDER\\Desktop\\test\\crawl_test.py&quot;, line 14, in &lt;module&gt; asyncio.run(main()) File &quot;E:\\python\\Lib\\asyncio\\runners.py&quot;, line 194, in run return runner.run(main) ^^^^^^^^^^^^^^^^ File &quot;E:\\python\\Lib\\asyncio\\runners.py&quot;, line 118, in run return self._loop.run_until_complete(task) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File &quot;E:\\python\\Lib\\asyncio\\base_events.py&quot;, line 687, in run_until_complete return future.result() ^^^^^^^^^^^^^^^ File &quot;c:\\Users\\EXDER\\Desktop\\test\\crawl_test.py&quot;, line 6, in main async with AsyncWebCrawler(verbose=True, browser_type=&#x27;chrome&#x27;) as crawler: File &quot;E:\\python\\Lib\\site-packages\\crawl4ai\\async_webcrawler.py&quot;, line 131, in __aenter__ await self.crawler_strategy.__aenter__() File &quot;E:\\python\\Lib\\site-packages\\crawl4ai\\async_crawler_strategy.py&quot;, line 500, in __aenter__ await self.start() File &quot;E:\\python\\Lib\\site-packages\\crawl4ai\\async_crawler_strategy.py&quot;, line 507, in start await self.browser_manager.start() File &quot;E:\\python\\Lib\\site-packages\\crawl4ai\\async_crawler_strategy.py&quot;, line 290, in start self.browser = await self.playwright.chromium.launch(**browser_args) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File &quot;E:\\python\\Lib\\site-packages\\playwright\\async_api\\_generated.py&quot;, line 14404, in launch await self._impl_obj.launch( File &quot;E:\\python\\Lib\\site-packages\\playwright\\_impl\\_browser_type.py&quot;, line 95, in launch Browser, from_channel(await self._channel.send(&quot;launch&quot;, params)) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File &quot;E:\\python\\Lib\\site-packages\\playwright\\_impl\\_connection.py&quot;, line 61, in send return await self._connection.wrap_api_call( ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File &quot;E:\\python\\Lib\\site-packages\\playwright\\_impl\\_connection.py&quot;, line 528, in wrap_api_call raise rewrite_error(error, f&quot;&#123;parsed_st[&#x27;apiName&#x27;]&#125;: &#123;error&#125;&quot;) from Noneplaywright._impl._errors.Error: BrowserType.launch: Chromium distribution &#x27;chrome&#x27; is not found at C:\\Users\\EXDER\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exeRun &quot;playwright install chrome&quot;Exception ignored in: &lt;function BaseSubprocessTransport.__del__ at 0x00000216290ECE00&gt;Traceback (most recent call last): File &quot;E:\\python\\Lib\\asyncio\\base_subprocess.py&quot;, line 126, in __del__ File &quot;E:\\python\\Lib\\asyncio\\base_subprocess.py&quot;, line 104, in close File &quot;E:\\python\\Lib\\asyncio\\proactor_events.py&quot;, line 109, in close File &quot;E:\\python\\Lib\\asyncio\\base_events.py&quot;, line 795, in call_soon File &quot;E:\\python\\Lib\\asyncio\\base_events.py&quot;, line 541, in _check_closedRuntimeError: Event loop is closed 修改为火狐浏览器： 1async with AsyncWebCrawler(verbose=True, browser_type=&#x27;firefox&#x27;) as crawler: 终于出现了正确的输出： 123456789[INIT].... → Crawl4AI 0.4.22[FETCH]... ↓ https://www.example.com/... | Status: True | Time: 0.02s[SCRAPE].. ◆ Processed https://www.example.com/... | Time: 2ms[COMPLETE] ● https://www.example.com/... | Status: True | Total: 0.03s# Example DomainThis domain is for use in illustrative examples in documents. You may use this domain in literature without prior coordination or asking for permission.[More information...](https://www.iana.org/domains/example) 但最奇怪的是，后续我尝试了 edge，safari 等浏览器，都显示无法正常运行，报错同上。似乎只有火狐可以。到底是什么原理呢。。。","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}],"author":"EXDER"},{"title":"学习网站整理","slug":"常用网站整理","date":"2023-11-11T16:00:00.000Z","updated":"2024-12-27T06:21:54.359Z","comments":true,"path":"2023/11/12/常用网站整理/","link":"","permalink":"http://example.com/2023/11/12/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/","excerpt":"note quote 给一些课程学习所需要的网站整理一下(虽然也不一定全会看但当时觉得有用就保存下来了的一些东西) 以便自己查询 日后会不断补充","text":"note quote 给一些课程学习所需要的网站整理一下(虽然也不一定全会看但当时觉得有用就保存下来了的一些东西) 以便自己查询 日后会不断补充 数字电路一个中科大编写的课程学习网站: Digital Lab 2023 (ustc.edu.cn) 包括 Verilog 语言学习 Logisim 使用教程 vivado 学习和仿真实验 (包括各种警告信息的含义 我觉得这个比较实用) 实验过程给的很详细 verilog 教程详细版: 1.1 Verilog 教程 | 菜鸟教程 (runoob.com) 清华大学 verilog 语言学习: Verilog 语言 - 计算机组成原理（2021 年） (tsinghua.edu.cn) 更详细的 logisim 上手教程: Logisim 的基本使用方法（详细）教你如何使用 Logisim_吾浴西风的博客-CSDN 博客 包括一些进阶组件的用法 助教老师编写的数字逻辑文档: 首页 (dld-ustb.github.io) 好用滴很呐!感谢助教老师们 而你们才是真正的英雄.jpg 数据结构与算法一位大佬的博客: jitwxs.cn 数据结构 第一章 概论 | Jitwxs 数据结构 第二章 线性表 | Jitwxs 数据结构 第三章 栈和队列 | Jitwxs 数据结构 第四章 串 | Jitwxs 数据结构 第五章 数组和广义表 | Jitwxs 数据结构 第六章 树和二叉树 | Jitwxs 数据结构 第七章 图 | Jitwxs 数据结构 第八章 排序 | Jitwxs 数据结构 第九章 查找 | Jitwxs 算法讲解视频: 十大经典排序算法（C 语言描述） 虽然 b 站各种讲解经典算法的视频非常多,但我看大部分视频都是会了思想不会敲代码( 这位老师会带着你边敲代码边讲解 推荐一下 大学物理(大雾)复习用 知识点总结 �� 讲: 大学物理上知识点总结 老师声音很好听(嗯) 知识点复习的很全面 还会讲经典例题 用来复习很不错 例题讲解:【强烈推荐】大学物理知识点回顾与典型题解析 主要是讲题 例题很典型 避免听懂了(大概)但不会做题的现象 详细课程: 大学物理（汇总版） 黎光旭主讲 （普通物理）力学，振动与波，相对论，电磁学 马文蔚物理学第七版 好评率非常高的一位老师 讲课很清晰风趣 如果时间多(不是一晚上速通)的话可以看看 模电课程: 【模电速成课】【拯救期末系列】【网课时代模电零基础复习】一周复习模电 还没开始看(嗯 期中靠这个救了 先放在这里看完了再评 线代线代的代本质: 线性代数的本质 - 01 - 向量究竟是什么 非常好的对矩阵和线代本质的探讨视频 推荐所有学习者在学线代之前观看 这下终于看懂在学什么了(如果没有这个视频 按照学校老师的无图授课模式估计结课了还不知道究竟学了个什么(悲)) 其它c++教程: C++ 教程 | 菜鸟教程 (runoob.com) linux 命令: Linux 命令大全 | 菜鸟教程 (runoob.com) ASCLL 码表: ASCII 码一览表，ASCII 码对照表 (biancheng.net) 正则表达式测试器: regex101: build, test, and debug regex 四六级真题: 六级真题(2012-2023 年 6 月) | 英语真题在线 (burningvocabulary.cn)","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网页","slug":"网页","permalink":"http://example.com/tags/%E7%BD%91%E9%A1%B5/"}],"author":"EXDER"}],"categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"},{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"http://example.com/tags/verilog/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"网页","slug":"网页","permalink":"http://example.com/tags/%E7%BD%91%E9%A1%B5/"}]}